{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HTTPCore","text":"<p>Do one thing, and do it well.</p> <p>The HTTP Core package provides a minimal low-level HTTP client, which does one thing only. Sending HTTP requests.</p> <p>It does not provide any high level model abstractions over the API, does not handle redirects, multipart uploads, building authentication headers, transparent HTTP caching, URL parsing, session cookie handling, content or charset decoding, handling JSON, environment based configuration defaults, or any of that Jazz.</p> <p>Some things HTTP Core does do:</p> <ul> <li>Sending HTTP requests.</li> <li>Thread-safe / task-safe connection pooling.</li> <li>HTTP(S) proxy &amp; SOCKS proxy support.</li> <li>Supports HTTP/1.1 and HTTP/2.</li> <li>Provides both sync and async interfaces.</li> <li>Async backend support for <code>asyncio</code> and <code>trio</code>.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.8+</p>"},{"location":"#installation","title":"Installation","text":"<p>For HTTP/1.1 only support, install with:</p> <pre><code>$ pip install httpcore\n</code></pre> <p>For HTTP/1.1 and HTTP/2 support, install with:</p> <pre><code>$ pip install httpcore[http2]\n</code></pre> <p>For SOCKS proxy support, install with:</p> <pre><code>$ pip install httpcore[socks]\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Let's check we're able to send HTTP requests:</p> <pre><code>import httpcore\n\nresponse = httpcore.request(\"GET\", \"https://www.example.com/\")\n\nprint(response)\n# &lt;Response [200]&gt;\nprint(response.status)\n# 200\nprint(response.headers)\n# [(b'Accept-Ranges', b'bytes'), (b'Age', b'557328'), (b'Cache-Control', b'max-age=604800'), ...]\nprint(response.content)\n# b'&lt;!doctype html&gt;\\n&lt;html&gt;\\n&lt;head&gt;\\n&lt;title&gt;Example Domain&lt;/title&gt;\\n\\n&lt;meta charset=\"utf-8\"/&gt;\\n ...'\n</code></pre> <p>Ready to get going?</p> <p>Head over to the quickstart documentation.</p>"},{"location":"async/","title":"Async Support","text":"<p>HTTPX offers a standard synchronous API by default, but also gives you the option of an async client if you need it.</p> <p>Async is a concurrency model that is far more efficient than multi-threading, and can provide significant performance benefits and enable the use of long-lived network connections such as WebSockets.</p> <p>If you're working with an async web framework then you'll also want to use an async client for sending outgoing HTTP requests.</p> <p>Launching concurrent async tasks is far more resource efficient than spawning multiple threads. The Python interpreter should be able to comfortably handle switching between over 1000 concurrent tasks, while a sensible number of threads in a thread pool might be to enable around 10 or 20 concurrent threads.</p>"},{"location":"async/#enabling-async-support","title":"Enabling Async support","text":"<p>If you're using async with Python's stdlib <code>asyncio</code> support, install the optional dependencies using:</p> <pre><code>$ pip install 'httpcore[asyncio]'\n</code></pre> <p>Alternatively, if you're working with the Python <code>trio</code> package:</p> <pre><code>$ pip install 'httpcore[trio]'\n</code></pre> <p>We highly recommend <code>trio</code> for async support. The <code>trio</code> project pioneered the principles of structured concurrency, and has a more carefully constrained API against which to work from.</p>"},{"location":"async/#api-differences","title":"API differences","text":"<p>When using async support, you need make sure to use an async connection pool class:</p> <pre><code># The async variation of `httpcore.ConnectionPool`\nasync with httpcore.AsyncConnectionPool() as http:\n    ...\n</code></pre>"},{"location":"async/#sending-requests","title":"Sending requests","text":"<p>Sending requests with the async version of <code>httpcore</code> requires the <code>await</code> keyword:</p> <pre><code>import asyncio\nimport httpcore\n\nasync def main():\n    async with httpcore.AsyncConnectionPool() as http:\n        response = await http.request(\"GET\", \"https://www.example.com/\")\n\n\nasyncio.run(main())\n</code></pre> <p>When including content in the request, the content must either be bytes or an async iterable yielding bytes.</p>"},{"location":"async/#streaming-responses","title":"Streaming responses","text":"<p>Streaming responses also require a slightly different interface to the sync version:</p> <ul> <li><code>with &lt;pool&gt;.stream(...) as response</code> \u2192 <code>async with &lt;pool&gt;.stream() as response</code>.</li> <li><code>for chunk in response.iter_stream()</code> \u2192 <code>async for chunk in response.aiter_stream()</code>.</li> <li><code>response.read()</code> \u2192 <code>await response.aread()</code>.</li> <li><code>response.close()</code> \u2192 <code>await response.aclose()</code></li> </ul> <p>For example:</p> <pre><code>import asyncio\nimport httpcore\n\n\nasync def main():\n    async with httpcore.AsyncConnectionPool() as http:\n        async with http.stream(\"GET\", \"https://www.example.com/\") as response:\n            async for chunk in response.aiter_stream():\n                print(f\"Downloaded: {chunk}\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"async/#pool-lifespans","title":"Pool lifespans","text":"<p>When using <code>httpcore</code> in an async environment it is strongly recommended that you instantiate and use connection pools using the context managed style:</p> <pre><code>async with httpcore.AsyncConnectionPool() as http:\n    ...\n</code></pre> <p>To benefit from connection pooling it is recommended that you instantiate a single connection pool in this style, and pass it around throughout your application.</p> <p>If you do want to use a connection pool without this style then you'll need to ensure that you explicitly close the pool once it is no longer required:</p> <pre><code>try:\n    http = httpcore.AsyncConnectionPool()\n    ...\nfinally:\n    await http.aclose()\n</code></pre> <p>This is a little different to the threaded context, where it's okay to simply instantiate a globally available connection pool, and then allow Python's garbage collection to deal with closing any connections in the pool, once the <code>__del__</code> method is called.</p> <p>The reason for this difference is that asynchronous code is not able to run within the context of the synchronous <code>__del__</code> method, so there is no way for connections to be automatically closed at the point of garbage collection. This can lead to unterminated TCP connections still remaining after the Python interpreter quits.</p>"},{"location":"async/#supported-environments","title":"Supported environments","text":"<p>HTTPX supports either <code>asyncio</code> or <code>trio</code> as an async environment.</p> <p>It will auto-detect which of those two to use as the backend for socket operations and concurrency primitives.</p>"},{"location":"async/#asyncio","title":"AsyncIO","text":"<p>AsyncIO is Python's built-in library for writing concurrent code with the async/await syntax.</p> <p>Let's take a look at sending several outgoing HTTP requests concurrently, using <code>asyncio</code>:</p> <pre><code>import asyncio\nimport httpcore\nimport time\n\n\nasync def download(http, year):\n    await http.request(\"GET\", f\"https://en.wikipedia.org/wiki/{year}\")\n\n\nasync def main():\n    async with httpcore.AsyncConnectionPool() as http:\n        started = time.time()\n        # Here we use `asyncio.gather()` in order to run several tasks concurrently...\n        tasks = [download(http, year) for year in range(2000, 2020)]\n        await asyncio.gather(*tasks)\n        complete = time.time()\n\n        for connection in http.connections:\n            print(connection)\n        print(\"Complete in %.3f seconds\" % (complete - started))\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"async/#trio","title":"Trio","text":"<p>Trio is an alternative async library, designed around the the principles of structured concurrency.</p> <pre><code>import httpcore\nimport trio\nimport time\n\n\nasync def download(http, year):\n    await http.request(\"GET\", f\"https://en.wikipedia.org/wiki/{year}\")\n\n\nasync def main():\n    async with httpcore.AsyncConnectionPool() as http:\n        started = time.time()\n        async with trio.open_nursery() as nursery:\n            for year in range(2000, 2020):\n                nursery.start_soon(download, http, year)\n        complete = time.time()\n\n        for connection in http.connections:\n            print(connection)\n        print(\"Complete in %.3f seconds\" % (complete - started))\n\n\ntrio.run(main)\n</code></pre>"},{"location":"async/#anyio","title":"AnyIO","text":"<p>AnyIO is an asynchronous networking and concurrency library that works on top of either asyncio or trio. It blends in with native libraries of your chosen backend (defaults to asyncio).</p> <p>The <code>anyio</code> library is designed around the the principles of structured concurrency, and brings many of the same correctness and usability benefits that Trio provides, while interoperating with existing <code>asyncio</code> libraries.</p> <pre><code>import httpcore\nimport anyio\nimport time\n\n\nasync def download(http, year):\n    await http.request(\"GET\", f\"https://en.wikipedia.org/wiki/{year}\")\n\n\nasync def main():\n    async with httpcore.AsyncConnectionPool() as http:\n        started = time.time()\n        async with anyio.create_task_group() as task_group:\n            for year in range(2000, 2020):\n                task_group.start_soon(download, http, year)\n        complete = time.time()\n\n        for connection in http.connections:\n            print(connection)\n        print(\"Complete in %.3f seconds\" % (complete - started))\n\n\nanyio.run(main)\n</code></pre>"},{"location":"async/#reference","title":"Reference","text":""},{"location":"async/#httpcoreasyncconnectionpool","title":"<code>httpcore.AsyncConnectionPool</code>","text":"<p>A connection pool for making HTTP requests.</p>"},{"location":"async/#httpcore.AsyncConnectionPool.connections","title":"<code>connections: list[AsyncConnectionInterface]</code>  <code>property</code> <code>readonly</code>","text":"<p>Return a list of the connections currently in the pool.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; pool.connections\n[\n    &lt;AsyncHTTPConnection ['https://example.com:443', HTTP/1.1, ACTIVE, Request Count: 6]&gt;,\n    &lt;AsyncHTTPConnection ['https://example.com:443', HTTP/1.1, IDLE, Request Count: 9]&gt; ,\n    &lt;AsyncHTTPConnection ['http://example.com:80', HTTP/1.1, IDLE, Request Count: 1]&gt;,\n]\n</code></pre>"},{"location":"async/#httpcore.AsyncConnectionPool.__init__","title":"<code>__init__(self, ssl_context=None, proxy=None, max_connections=10, max_keepalive_connections=None, keepalive_expiry=None, http1=True, http2=False, retries=0, local_address=None, uds=None, network_backend=None, socket_options=None)</code>  <code>special</code>","text":"<p>A connection pool for making HTTP requests.</p> <p>Parameters:</p> Name Type Description Default <code>ssl_context</code> <code>ssl.SSLContext | None</code> <p>An SSL context to use for verifying connections. If not specified, the default <code>httpcore.default_ssl_context()</code> will be used.</p> <code>None</code> <code>max_connections</code> <code>int | None</code> <p>The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available.</p> <code>10</code> <code>max_keepalive_connections</code> <code>int | None</code> <p>The maximum number of idle HTTP connections that will be maintained in the pool.</p> <code>None</code> <code>keepalive_expiry</code> <code>float | None</code> <p>The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool.</p> <code>None</code> <code>http1</code> <code>bool</code> <p>A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True.</p> <code>True</code> <code>http2</code> <code>bool</code> <p>A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False.</p> <code>False</code> <code>retries</code> <code>int</code> <p>The maximum number of retries when trying to establish a connection.</p> <code>0</code> <code>local_address</code> <code>str | None</code> <p>Local address to connect from. Can also be used to connect using a particular address family. Using <code>local_address=\"0.0.0.0\"</code> will connect using an <code>AF_INET</code> address (IPv4), while using <code>local_address=\"::\"</code> will connect using an <code>AF_INET6</code> address (IPv6).</p> <code>None</code> <code>uds</code> <code>str | None</code> <p>Path to a Unix Domain Socket to use instead of TCP sockets.</p> <code>None</code> <code>network_backend</code> <code>AsyncNetworkBackend | None</code> <p>A backend instance to use for handling network I/O.</p> <code>None</code> <code>socket_options</code> <code>Iterable[SOCKET_OPTION] | None</code> <p>Socket options that have to be included in the TCP socket when the connection was established.</p> <code>None</code> Source code in <code>httpcore/__init__.py</code> <pre><code>def __init__(\n    self,\n    ssl_context: ssl.SSLContext | None = None,\n    proxy: Proxy | None = None,\n    max_connections: int | None = 10,\n    max_keepalive_connections: int | None = None,\n    keepalive_expiry: float | None = None,\n    http1: bool = True,\n    http2: bool = False,\n    retries: int = 0,\n    local_address: str | None = None,\n    uds: str | None = None,\n    network_backend: AsyncNetworkBackend | None = None,\n    socket_options: typing.Iterable[SOCKET_OPTION] | None = None,\n) -&gt; None:\n    \"\"\"\n    A connection pool for making HTTP requests.\n\n    Parameters:\n        ssl_context: An SSL context to use for verifying connections.\n            If not specified, the default `httpcore.default_ssl_context()`\n            will be used.\n        max_connections: The maximum number of concurrent HTTP connections that\n            the pool should allow. Any attempt to send a request on a pool that\n            would exceed this amount will block until a connection is available.\n        max_keepalive_connections: The maximum number of idle HTTP connections\n            that will be maintained in the pool.\n        keepalive_expiry: The duration in seconds that an idle HTTP connection\n            may be maintained for before being expired from the pool.\n        http1: A boolean indicating if HTTP/1.1 requests should be supported\n            by the connection pool. Defaults to True.\n        http2: A boolean indicating if HTTP/2 requests should be supported by\n            the connection pool. Defaults to False.\n        retries: The maximum number of retries when trying to establish a\n            connection.\n        local_address: Local address to connect from. Can also be used to connect\n            using a particular address family. Using `local_address=\"0.0.0.0\"`\n            will connect using an `AF_INET` address (IPv4), while using\n            `local_address=\"::\"` will connect using an `AF_INET6` address (IPv6).\n        uds: Path to a Unix Domain Socket to use instead of TCP sockets.\n        network_backend: A backend instance to use for handling network I/O.\n        socket_options: Socket options that have to be included\n         in the TCP socket when the connection was established.\n    \"\"\"\n    self._ssl_context = ssl_context\n    self._proxy = proxy\n    self._max_connections = (\n        sys.maxsize if max_connections is None else max_connections\n    )\n    self._max_keepalive_connections = (\n        sys.maxsize\n        if max_keepalive_connections is None\n        else max_keepalive_connections\n    )\n    self._max_keepalive_connections = min(\n        self._max_connections, self._max_keepalive_connections\n    )\n\n    self._keepalive_expiry = keepalive_expiry\n    self._http1 = http1\n    self._http2 = http2\n    self._retries = retries\n    self._local_address = local_address\n    self._uds = uds\n\n    self._network_backend = (\n        AutoBackend() if network_backend is None else network_backend\n    )\n    self._socket_options = socket_options\n\n    # The mutable state on a connection pool is the queue of incoming requests,\n    # and the set of connections that are servicing those requests.\n    self._connections: list[AsyncConnectionInterface] = []\n    self._requests: list[AsyncPoolRequest] = []\n\n    # We only mutate the state of the connection pool within an 'optional_thread_lock'\n    # context. This holds a threading lock unless we're running in async mode,\n    # in which case it is a no-op.\n    self._optional_thread_lock = AsyncThreadLock()\n</code></pre>"},{"location":"async/#httpcore.AsyncConnectionPool.handle_async_request","title":"<code>handle_async_request(self, request)</code>  <code>async</code>","text":"<p>Send an HTTP request, and return an HTTP response.</p> <p>This is the core implementation that is called into by <code>.request()</code> or <code>.stream()</code>.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>async def handle_async_request(self, request: Request) -&gt; Response:\n    \"\"\"\n    Send an HTTP request, and return an HTTP response.\n\n    This is the core implementation that is called into by `.request()` or `.stream()`.\n    \"\"\"\n    scheme = request.url.scheme.decode()\n    if scheme == \"\":\n        raise UnsupportedProtocol(\n            \"Request URL is missing an 'http://' or 'https://' protocol.\"\n        )\n    if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n        raise UnsupportedProtocol(\n            f\"Request URL has an unsupported protocol '{scheme}://'.\"\n        )\n\n    timeouts = request.extensions.get(\"timeout\", {})\n    timeout = timeouts.get(\"pool\", None)\n\n    with self._optional_thread_lock:\n        # Add the incoming request to our request queue.\n        pool_request = AsyncPoolRequest(request)\n        self._requests.append(pool_request)\n\n    try:\n        while True:\n            with self._optional_thread_lock:\n                # Assign incoming requests to available connections,\n                # closing or creating new connections as required.\n                closing = self._assign_requests_to_connections()\n            await self._close_connections(closing)\n\n            # Wait until this request has an assigned connection.\n            connection = await pool_request.wait_for_connection(timeout=timeout)\n\n            try:\n                # Send the request on the assigned connection.\n                response = await connection.handle_async_request(\n                    pool_request.request\n                )\n            except ConnectionNotAvailable:\n                # In some cases a connection may initially be available to\n                # handle a request, but then become unavailable.\n                #\n                # In this case we clear the connection and try again.\n                pool_request.clear_connection()\n            else:\n                break  # pragma: nocover\n\n    except BaseException as exc:\n        with self._optional_thread_lock:\n            # For any exception or cancellation we remove the request from\n            # the queue, and then re-assign requests to connections.\n            self._requests.remove(pool_request)\n            closing = self._assign_requests_to_connections()\n\n        await self._close_connections(closing)\n        raise exc from None\n\n    # Return the response. Note that in this case we still have to manage\n    # the point at which the response is closed.\n    assert isinstance(response.stream, typing.AsyncIterable)\n    return Response(\n        status=response.status,\n        headers=response.headers,\n        content=PoolByteStream(\n            stream=response.stream, pool_request=pool_request, pool=self\n        ),\n        extensions=response.extensions,\n    )\n</code></pre>"},{"location":"connection-pools/","title":"Connection Pools","text":"<p>While the top-level API provides convenience functions for working with <code>httpcore</code>, in practice you'll almost always want to take advantage of the connection pooling functionality that it provides.</p> <p>To do so, instantiate a pool instance, and use it to send requests:</p> <pre><code>import httpcore\n\nhttp = httpcore.ConnectionPool()\nr = http.request(\"GET\", \"https://www.example.com/\")\n\nprint(r)\n# &lt;Response [200]&gt;\n</code></pre> <p>Connection pools support the same <code>.request()</code> and <code>.stream()</code> APIs as described in the Quickstart.</p> <p>We can observe the benefits of connection pooling with a simple script like so:</p> <pre><code>import httpcore\nimport time\n\n\nhttp = httpcore.ConnectionPool()\nfor counter in range(5):\n    started = time.time()\n    response = http.request(\"GET\", \"https://www.example.com/\")\n    complete = time.time()\n    print(response, \"in %.3f seconds\" % (complete - started))\n</code></pre> <p>The output should demonstrate the initial request as being substantially slower than the subsequent requests:</p> <pre><code>&lt;Response [200]&gt; in {0.529} seconds\n&lt;Response [200]&gt; in {0.096} seconds\n&lt;Response [200]&gt; in {0.097} seconds\n&lt;Response [200]&gt; in {0.095} seconds\n&lt;Response [200]&gt; in {0.098} seconds\n</code></pre> <p>This is to be expected. Once we've established a connection to <code>\"www.example.com\"</code> we're able to reuse it for following requests.</p>"},{"location":"connection-pools/#configuration","title":"Configuration","text":"<p>The connection pool instance is also the main point of configuration. Let's take a look at the various options that it provides:</p>"},{"location":"connection-pools/#ssl-configuration","title":"SSL configuration","text":"<ul> <li><code>ssl_context</code>: An SSL context to use for verifying connections.                  If not specified, the default <code>httpcore.default_ssl_context()</code>                  will be used.</li> </ul>"},{"location":"connection-pools/#pooling-configuration","title":"Pooling configuration","text":"<ul> <li><code>max_connections</code>: The maximum number of concurrent HTTP connections that the pool                      should allow. Any attempt to send a request on a pool that would                      exceed this amount will block until a connection is available.</li> <li><code>max_keepalive_connections</code>: The maximum number of idle HTTP connections that will                                be maintained in the pool.</li> <li><code>keepalive_expiry</code>: The duration in seconds that an idle HTTP connection may be                       maintained for before being expired from the pool.</li> </ul>"},{"location":"connection-pools/#http-version-support","title":"HTTP version support","text":"<ul> <li><code>http1</code>: A boolean indicating if HTTP/1.1 requests should be supported by the connection            pool. Defaults to <code>True</code>.</li> <li><code>http2</code>: A boolean indicating if HTTP/2 requests should be supported by the connection            pool. Defaults to <code>False</code>.</li> </ul>"},{"location":"connection-pools/#other-options","title":"Other options","text":"<ul> <li><code>retries</code>: The maximum number of retries when trying to establish a connection.</li> <li><code>local_address</code>: Local address to connect from. Can also be used to connect using                    a particular address family. Using <code>local_address=\"0.0.0.0\"</code> will                    connect using an <code>AF_INET</code> address (IPv4), while using <code>local_address=\"::\"</code>                    will connect using an <code>AF_INET6</code> address (IPv6).</li> <li><code>uds</code>: Path to a Unix Domain Socket to use instead of TCP sockets.</li> <li><code>network_backend</code>: A backend instance to use for handling network I/O.</li> <li><code>socket_options</code>: Socket options that have to be included in the TCP socket when the connection was established.</li> </ul>"},{"location":"connection-pools/#pool-lifespans","title":"Pool lifespans","text":"<p>Because connection pools hold onto network resources, careful developers may want to ensure that instances are properly closed once they are no longer required.</p> <p>Working with a single global instance isn't a bad idea for many use case, since the connection pool will automatically be closed when the <code>__del__</code> method is called on it:</p> <pre><code># This is perfectly fine for most purposes.\n# The connection pool will automatically be closed when it is garbage collected,\n# or when the Python interpreter exits.\nhttp = httpcore.ConnectionPool()\n</code></pre> <p>However, to be more explicit around the resource usage, we can use the connection pool within a context manager:</p> <pre><code>with httpcore.ConnectionPool() as http:\n    ...\n</code></pre> <p>Or else close the pool explicitly:</p> <pre><code>http = httpcore.ConnectionPool()\ntry:\n    ...\nfinally:\n    http.close()\n</code></pre>"},{"location":"connection-pools/#thread-and-task-safety","title":"Thread and task safety","text":"<p>Connection pools are designed to be thread-safe. Similarly, when using <code>httpcore</code> in an async context connection pools are task-safe.</p> <p>This means that you can have a single connection pool instance shared by multiple threads.</p>"},{"location":"connection-pools/#reference","title":"Reference","text":""},{"location":"connection-pools/#httpcoreconnectionpool","title":"<code>httpcore.ConnectionPool</code>","text":"<p>A connection pool for making HTTP requests.</p>"},{"location":"connection-pools/#httpcore.ConnectionPool.connections","title":"<code>connections: list[ConnectionInterface]</code>  <code>property</code> <code>readonly</code>","text":"<p>Return a list of the connections currently in the pool.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; pool.connections\n[\n    &lt;HTTPConnection ['https://example.com:443', HTTP/1.1, ACTIVE, Request Count: 6]&gt;,\n    &lt;HTTPConnection ['https://example.com:443', HTTP/1.1, IDLE, Request Count: 9]&gt; ,\n    &lt;HTTPConnection ['http://example.com:80', HTTP/1.1, IDLE, Request Count: 1]&gt;,\n]\n</code></pre>"},{"location":"connection-pools/#httpcore.ConnectionPool.__init__","title":"<code>__init__(self, ssl_context=None, proxy=None, max_connections=10, max_keepalive_connections=None, keepalive_expiry=None, http1=True, http2=False, retries=0, local_address=None, uds=None, network_backend=None, socket_options=None)</code>  <code>special</code>","text":"<p>A connection pool for making HTTP requests.</p> <p>Parameters:</p> Name Type Description Default <code>ssl_context</code> <code>ssl.SSLContext | None</code> <p>An SSL context to use for verifying connections. If not specified, the default <code>httpcore.default_ssl_context()</code> will be used.</p> <code>None</code> <code>max_connections</code> <code>int | None</code> <p>The maximum number of concurrent HTTP connections that the pool should allow. Any attempt to send a request on a pool that would exceed this amount will block until a connection is available.</p> <code>10</code> <code>max_keepalive_connections</code> <code>int | None</code> <p>The maximum number of idle HTTP connections that will be maintained in the pool.</p> <code>None</code> <code>keepalive_expiry</code> <code>float | None</code> <p>The duration in seconds that an idle HTTP connection may be maintained for before being expired from the pool.</p> <code>None</code> <code>http1</code> <code>bool</code> <p>A boolean indicating if HTTP/1.1 requests should be supported by the connection pool. Defaults to True.</p> <code>True</code> <code>http2</code> <code>bool</code> <p>A boolean indicating if HTTP/2 requests should be supported by the connection pool. Defaults to False.</p> <code>False</code> <code>retries</code> <code>int</code> <p>The maximum number of retries when trying to establish a connection.</p> <code>0</code> <code>local_address</code> <code>str | None</code> <p>Local address to connect from. Can also be used to connect using a particular address family. Using <code>local_address=\"0.0.0.0\"</code> will connect using an <code>AF_INET</code> address (IPv4), while using <code>local_address=\"::\"</code> will connect using an <code>AF_INET6</code> address (IPv6).</p> <code>None</code> <code>uds</code> <code>str | None</code> <p>Path to a Unix Domain Socket to use instead of TCP sockets.</p> <code>None</code> <code>network_backend</code> <code>NetworkBackend | None</code> <p>A backend instance to use for handling network I/O.</p> <code>None</code> <code>socket_options</code> <code>Iterable[SOCKET_OPTION] | None</code> <p>Socket options that have to be included in the TCP socket when the connection was established.</p> <code>None</code> Source code in <code>httpcore/__init__.py</code> <pre><code>def __init__(\n    self,\n    ssl_context: ssl.SSLContext | None = None,\n    proxy: Proxy | None = None,\n    max_connections: int | None = 10,\n    max_keepalive_connections: int | None = None,\n    keepalive_expiry: float | None = None,\n    http1: bool = True,\n    http2: bool = False,\n    retries: int = 0,\n    local_address: str | None = None,\n    uds: str | None = None,\n    network_backend: NetworkBackend | None = None,\n    socket_options: typing.Iterable[SOCKET_OPTION] | None = None,\n) -&gt; None:\n    \"\"\"\n    A connection pool for making HTTP requests.\n\n    Parameters:\n        ssl_context: An SSL context to use for verifying connections.\n            If not specified, the default `httpcore.default_ssl_context()`\n            will be used.\n        max_connections: The maximum number of concurrent HTTP connections that\n            the pool should allow. Any attempt to send a request on a pool that\n            would exceed this amount will block until a connection is available.\n        max_keepalive_connections: The maximum number of idle HTTP connections\n            that will be maintained in the pool.\n        keepalive_expiry: The duration in seconds that an idle HTTP connection\n            may be maintained for before being expired from the pool.\n        http1: A boolean indicating if HTTP/1.1 requests should be supported\n            by the connection pool. Defaults to True.\n        http2: A boolean indicating if HTTP/2 requests should be supported by\n            the connection pool. Defaults to False.\n        retries: The maximum number of retries when trying to establish a\n            connection.\n        local_address: Local address to connect from. Can also be used to connect\n            using a particular address family. Using `local_address=\"0.0.0.0\"`\n            will connect using an `AF_INET` address (IPv4), while using\n            `local_address=\"::\"` will connect using an `AF_INET6` address (IPv6).\n        uds: Path to a Unix Domain Socket to use instead of TCP sockets.\n        network_backend: A backend instance to use for handling network I/O.\n        socket_options: Socket options that have to be included\n         in the TCP socket when the connection was established.\n    \"\"\"\n    self._ssl_context = ssl_context\n    self._proxy = proxy\n    self._max_connections = (\n        sys.maxsize if max_connections is None else max_connections\n    )\n    self._max_keepalive_connections = (\n        sys.maxsize\n        if max_keepalive_connections is None\n        else max_keepalive_connections\n    )\n    self._max_keepalive_connections = min(\n        self._max_connections, self._max_keepalive_connections\n    )\n\n    self._keepalive_expiry = keepalive_expiry\n    self._http1 = http1\n    self._http2 = http2\n    self._retries = retries\n    self._local_address = local_address\n    self._uds = uds\n\n    self._network_backend = (\n        SyncBackend() if network_backend is None else network_backend\n    )\n    self._socket_options = socket_options\n\n    # The mutable state on a connection pool is the queue of incoming requests,\n    # and the set of connections that are servicing those requests.\n    self._connections: list[ConnectionInterface] = []\n    self._requests: list[PoolRequest] = []\n\n    # We only mutate the state of the connection pool within an 'optional_thread_lock'\n    # context. This holds a threading lock unless we're running in async mode,\n    # in which case it is a no-op.\n    self._optional_thread_lock = ThreadLock()\n</code></pre>"},{"location":"connection-pools/#httpcore.ConnectionPool.handle_request","title":"<code>handle_request(self, request)</code>","text":"<p>Send an HTTP request, and return an HTTP response.</p> <p>This is the core implementation that is called into by <code>.request()</code> or <code>.stream()</code>.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def handle_request(self, request: Request) -&gt; Response:\n    \"\"\"\n    Send an HTTP request, and return an HTTP response.\n\n    This is the core implementation that is called into by `.request()` or `.stream()`.\n    \"\"\"\n    scheme = request.url.scheme.decode()\n    if scheme == \"\":\n        raise UnsupportedProtocol(\n            \"Request URL is missing an 'http://' or 'https://' protocol.\"\n        )\n    if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n        raise UnsupportedProtocol(\n            f\"Request URL has an unsupported protocol '{scheme}://'.\"\n        )\n\n    timeouts = request.extensions.get(\"timeout\", {})\n    timeout = timeouts.get(\"pool\", None)\n\n    with self._optional_thread_lock:\n        # Add the incoming request to our request queue.\n        pool_request = PoolRequest(request)\n        self._requests.append(pool_request)\n\n    try:\n        while True:\n            with self._optional_thread_lock:\n                # Assign incoming requests to available connections,\n                # closing or creating new connections as required.\n                closing = self._assign_requests_to_connections()\n            self._close_connections(closing)\n\n            # Wait until this request has an assigned connection.\n            connection = pool_request.wait_for_connection(timeout=timeout)\n\n            try:\n                # Send the request on the assigned connection.\n                response = connection.handle_request(\n                    pool_request.request\n                )\n            except ConnectionNotAvailable:\n                # In some cases a connection may initially be available to\n                # handle a request, but then become unavailable.\n                #\n                # In this case we clear the connection and try again.\n                pool_request.clear_connection()\n            else:\n                break  # pragma: nocover\n\n    except BaseException as exc:\n        with self._optional_thread_lock:\n            # For any exception or cancellation we remove the request from\n            # the queue, and then re-assign requests to connections.\n            self._requests.remove(pool_request)\n            closing = self._assign_requests_to_connections()\n\n        self._close_connections(closing)\n        raise exc from None\n\n    # Return the response. Note that in this case we still have to manage\n    # the point at which the response is closed.\n    assert isinstance(response.stream, typing.Iterable)\n    return Response(\n        status=response.status,\n        headers=response.headers,\n        content=PoolByteStream(\n            stream=response.stream, pool_request=pool_request, pool=self\n        ),\n        extensions=response.extensions,\n    )\n</code></pre>"},{"location":"connections/","title":"Connections","text":"<p>TODO</p>"},{"location":"connections/#reference","title":"Reference","text":""},{"location":"connections/#httpcorehttpconnection","title":"<code>httpcore.HTTPConnection</code>","text":""},{"location":"connections/#httpcore.HTTPConnection.has_expired","title":"<code>has_expired(self)</code>","text":"<p>Return <code>True</code> if the connection is in a state where it should be closed.</p> <p>This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def has_expired(self) -&gt; bool:\n    if self._connection is None:\n        return self._connect_failed\n    return self._connection.has_expired()\n</code></pre>"},{"location":"connections/#httpcore.HTTPConnection.is_available","title":"<code>is_available(self)</code>","text":"<p>Return <code>True</code> if the connection is currently able to accept an outgoing request.</p> <p>An HTTP/1.1 connection will only be available if it is currently idle.</p> <p>An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state.</p> <p>While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise <code>NewConnectionRequired</code> required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_available(self) -&gt; bool:\n    if self._connection is None:\n        # If HTTP/2 support is enabled, and the resulting connection could\n        # end up as HTTP/2 then we should indicate the connection as being\n        # available to service multiple requests.\n        return (\n            self._http2\n            and (self._origin.scheme == b\"https\" or not self._http1)\n            and not self._connect_failed\n        )\n    return self._connection.is_available()\n</code></pre>"},{"location":"connections/#httpcore.HTTPConnection.is_closed","title":"<code>is_closed(self)</code>","text":"<p>Return <code>True</code> if the connection has been closed.</p> <p>Used when a response is closed to determine if the connection may be returned to the connection pool or not.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_closed(self) -&gt; bool:\n    if self._connection is None:\n        return self._connect_failed\n    return self._connection.is_closed()\n</code></pre>"},{"location":"connections/#httpcore.HTTPConnection.is_idle","title":"<code>is_idle(self)</code>","text":"<p>Return <code>True</code> if the connection is currently idle.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_idle(self) -&gt; bool:\n    if self._connection is None:\n        return self._connect_failed\n    return self._connection.is_idle()\n</code></pre>"},{"location":"connections/#httpcorehttp11connection","title":"<code>httpcore.HTTP11Connection</code>","text":""},{"location":"connections/#httpcore.HTTP11Connection.has_expired","title":"<code>has_expired(self)</code>","text":"<p>Return <code>True</code> if the connection is in a state where it should be closed.</p> <p>This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def has_expired(self) -&gt; bool:\n    now = time.monotonic()\n    keepalive_expired = self._expire_at is not None and now &gt; self._expire_at\n\n    # If the HTTP connection is idle but the socket is readable, then the\n    # only valid state is that the socket is about to return b\"\", indicating\n    # a server-initiated disconnect.\n    server_disconnected = (\n        self._state == HTTPConnectionState.IDLE\n        and self._network_stream.get_extra_info(\"is_readable\")\n    )\n\n    return keepalive_expired or server_disconnected\n</code></pre>"},{"location":"connections/#httpcore.HTTP11Connection.is_available","title":"<code>is_available(self)</code>","text":"<p>Return <code>True</code> if the connection is currently able to accept an outgoing request.</p> <p>An HTTP/1.1 connection will only be available if it is currently idle.</p> <p>An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state.</p> <p>While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise <code>NewConnectionRequired</code> required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_available(self) -&gt; bool:\n    # Note that HTTP/1.1 connections in the \"NEW\" state are not treated as\n    # being \"available\". The control flow which created the connection will\n    # be able to send an outgoing request, but the connection will not be\n    # acquired from the connection pool for any other request.\n    return self._state == HTTPConnectionState.IDLE\n</code></pre>"},{"location":"connections/#httpcore.HTTP11Connection.is_closed","title":"<code>is_closed(self)</code>","text":"<p>Return <code>True</code> if the connection has been closed.</p> <p>Used when a response is closed to determine if the connection may be returned to the connection pool or not.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_closed(self) -&gt; bool:\n    return self._state == HTTPConnectionState.CLOSED\n</code></pre>"},{"location":"connections/#httpcore.HTTP11Connection.is_idle","title":"<code>is_idle(self)</code>","text":"<p>Return <code>True</code> if the connection is currently idle.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_idle(self) -&gt; bool:\n    return self._state == HTTPConnectionState.IDLE\n</code></pre>"},{"location":"connections/#httpcorehttp2connection","title":"<code>httpcore.HTTP2Connection</code>","text":""},{"location":"connections/#httpcore.HTTP2Connection.has_expired","title":"<code>has_expired(self)</code>","text":"<p>Return <code>True</code> if the connection is in a state where it should be closed.</p> <p>This either means that the connection is idle and it has passed the expiry time on its keep-alive, or that server has sent an EOF.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def has_expired(self) -&gt; bool:\n    now = time.monotonic()\n    return self._expire_at is not None and now &gt; self._expire_at\n</code></pre>"},{"location":"connections/#httpcore.HTTP2Connection.is_available","title":"<code>is_available(self)</code>","text":"<p>Return <code>True</code> if the connection is currently able to accept an outgoing request.</p> <p>An HTTP/1.1 connection will only be available if it is currently idle.</p> <p>An HTTP/2 connection will be available so long as the stream ID space is not yet exhausted, and the connection is not in an error state.</p> <p>While the connection is being established we may not yet know if it is going to result in an HTTP/1.1 or HTTP/2 connection. The connection should be treated as being available, but might ultimately raise <code>NewConnectionRequired</code> required exceptions if multiple requests are attempted over a connection that ends up being established as HTTP/1.1.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_available(self) -&gt; bool:\n    return (\n        self._state != HTTPConnectionState.CLOSED\n        and not self._connection_error\n        and not self._used_all_stream_ids\n        and not (\n            self._h2_state.state_machine.state\n            == h2.connection.ConnectionState.CLOSED\n        )\n    )\n</code></pre>"},{"location":"connections/#httpcore.HTTP2Connection.is_closed","title":"<code>is_closed(self)</code>","text":"<p>Return <code>True</code> if the connection has been closed.</p> <p>Used when a response is closed to determine if the connection may be returned to the connection pool or not.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_closed(self) -&gt; bool:\n    return self._state == HTTPConnectionState.CLOSED\n</code></pre>"},{"location":"connections/#httpcore.HTTP2Connection.is_idle","title":"<code>is_idle(self)</code>","text":"<p>Return <code>True</code> if the connection is currently idle.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def is_idle(self) -&gt; bool:\n    return self._state == HTTPConnectionState.IDLE\n</code></pre>"},{"location":"exceptions/","title":"Exceptions","text":"<p>The following exceptions may be raised when sending a request:</p> <ul> <li><code>httpcore.TimeoutException</code><ul> <li><code>httpcore.PoolTimeout</code></li> <li><code>httpcore.ConnectTimeout</code></li> <li><code>httpcore.ReadTimeout</code></li> <li><code>httpcore.WriteTimeout</code></li> </ul> </li> <li><code>httpcore.NetworkError</code><ul> <li><code>httpcore.ConnectError</code></li> <li><code>httpcore.ReadError</code></li> <li><code>httpcore.WriteError</code></li> </ul> </li> <li><code>httpcore.ProtocolError</code><ul> <li><code>httpcore.RemoteProtocolError</code></li> <li><code>httpcore.LocalProtocolError</code></li> </ul> </li> <li><code>httpcore.ProxyError</code></li> <li><code>httpcore.UnsupportedProtocol</code></li> </ul>"},{"location":"extensions/","title":"Extensions","text":"<p>The request/response API used by <code>httpcore</code> is kept deliberately simple and explicit.</p> <p>The <code>Request</code> and <code>Response</code> models are pretty slim wrappers around this core API:</p> <pre><code># Pseudo-code expressing the essentials of the request/response model.\n(\n    status_code: int,\n    headers: List[Tuple(bytes, bytes)],\n    stream: Iterable[bytes]\n) = handle_request(\n    method: bytes,\n    url: URL,\n    headers: List[Tuple(bytes, bytes)],\n    stream: Iterable[bytes]\n)\n</code></pre> <p>This is everything that's needed in order to represent an HTTP exchange.</p> <p>Well... almost.</p> <p>There is a maxim in Computer Science that \"All non-trivial abstractions, to some degree, are leaky\". When an expression is leaky, it's important that it ought to at least leak only in well-defined places.</p> <p>In order to handle cases that don't otherwise fit inside this core abstraction, <code>httpcore</code> requests and responses have 'extensions'. These are a dictionary of optional additional information.</p> <p>Let's expand on our request/response abstraction...</p> <pre><code># Pseudo-code expressing the essentials of the request/response model,\n# plus extensions allowing for additional API that does not fit into\n# this abstraction.\n(\n    status_code: int,\n    headers: List[Tuple(bytes, bytes)],\n    stream: Iterable[bytes],\n    extensions: dict\n) = handle_request(\n    method: bytes,\n    url: URL,\n    headers: List[Tuple(bytes, bytes)],\n    stream: Iterable[bytes],\n    extensions: dict\n)\n</code></pre> <p>Several extensions are supported both on the request:</p> <pre><code>r = httpcore.request(\n    \"GET\",\n    \"https://www.example.com\",\n    extensions={\"timeout\": {\"connect\": 5.0}}\n)\n</code></pre> <p>And on the response:</p> <pre><code>r = httpcore.request(\"GET\", \"https://www.example.com\")\n\nprint(r.extensions[\"http_version\"])\n# When using HTTP/1.1 on the client side, the server HTTP response\n# could feasibly be one of b\"HTTP/0.9\", b\"HTTP/1.0\", or b\"HTTP/1.1\".\n</code></pre>"},{"location":"extensions/#request-extensions","title":"Request Extensions","text":""},{"location":"extensions/#timeout","title":"<code>\"timeout\"</code>","text":"<p>A dictionary of <code>str: Optional[float]</code> timeout values.</p> <p>May include values for <code>'connect'</code>, <code>'read'</code>, <code>'write'</code>, or <code>'pool'</code>.</p> <p>For example:</p> <pre><code># Timeout if a connection takes more than 5 seconds to established, or if\n# we are blocked waiting on the connection pool for more than 10 seconds.\nr = httpcore.request(\n    \"GET\",\n    \"https://www.example.com\",\n    extensions={\"timeout\": {\"connect\": 5.0, \"pool\": 10.0}}\n)\n</code></pre>"},{"location":"extensions/#trace","title":"<code>\"trace\"</code>","text":"<p>The trace extension allows a callback handler to be installed to monitor the internal flow of events within <code>httpcore</code>. The simplest way to explain this is with an example:</p> <pre><code>import httpcore\n\ndef log(event_name, info):\n    print(event_name, info)\n\nr = httpcore.request(\"GET\", \"https://www.example.com/\", extensions={\"trace\": log})\n# connection.connect_tcp.started {'host': 'www.example.com', 'port': 443, 'local_address': None, 'timeout': None}\n# connection.connect_tcp.complete {'return_value': &lt;httpcore.backends.sync.SyncStream object at 0x1093f94d0&gt;}\n# connection.start_tls.started {'ssl_context': &lt;ssl.SSLContext object at 0x1093ee750&gt;, 'server_hostname': b'www.example.com', 'timeout': None}\n# connection.start_tls.complete {'return_value': &lt;httpcore.backends.sync.SyncStream object at 0x1093f9450&gt;}\n# http11.send_request_headers.started {'request': &lt;Request [b'GET']&gt;}\n# http11.send_request_headers.complete {'return_value': None}\n# http11.send_request_body.started {'request': &lt;Request [b'GET']&gt;}\n# http11.send_request_body.complete {'return_value': None}\n# http11.receive_response_headers.started {'request': &lt;Request [b'GET']&gt;}\n# http11.receive_response_headers.complete {'return_value': (b'HTTP/1.1', 200, b'OK', [(b'Age', b'553715'), (b'Cache-Control', b'max-age=604800'), (b'Content-Type', b'text/html; charset=UTF-8'), (b'Date', b'Thu, 21 Oct 2021 17:08:42 GMT'), (b'Etag', b'\"3147526947+ident\"'), (b'Expires', b'Thu, 28 Oct 2021 17:08:42 GMT'), (b'Last-Modified', b'Thu, 17 Oct 2019 07:18:26 GMT'), (b'Server', b'ECS (nyb/1DCD)'), (b'Vary', b'Accept-Encoding'), (b'X-Cache', b'HIT'), (b'Content-Length', b'1256')])}\n# http11.receive_response_body.started {'request': &lt;Request [b'GET']&gt;}\n# http11.receive_response_body.complete {'return_value': None}\n# http11.response_closed.started {}\n# http11.response_closed.complete {'return_value': None}\n</code></pre> <p>The <code>event_name</code> and <code>info</code> arguments here will be one of the following:</p> <ul> <li><code>{event_type}.{event_name}.started</code>, <code>&lt;dictionary of keyword arguments&gt;</code></li> <li><code>{event_type}.{event_name}.complete</code>, <code>{\"return_value\": &lt;...&gt;}</code></li> <li><code>{event_type}.{event_name}.failed</code>, <code>{\"exception\": &lt;...&gt;}</code></li> </ul> <p>Note that when using the async variant of <code>httpcore</code> the handler function passed to <code>\"trace\"</code> must be an <code>async def ...</code> function.</p> <p>The following event types are currently exposed...</p> <p>Establishing the connection</p> <ul> <li><code>\"connection.connect_tcp\"</code></li> <li><code>\"connection.connect_unix_socket\"</code></li> <li><code>\"connection.start_tls\"</code></li> </ul> <p>HTTP/1.1 events</p> <ul> <li><code>\"http11.send_request_headers\"</code></li> <li><code>\"http11.send_request_body\"</code></li> <li><code>\"http11.receive_response\"</code></li> <li><code>\"http11.receive_response_body\"</code></li> <li><code>\"http11.response_closed\"</code></li> </ul> <p>HTTP/2 events</p> <ul> <li><code>\"http2.send_connection_init\"</code></li> <li><code>\"http2.send_request_headers\"</code></li> <li><code>\"http2.send_request_body\"</code></li> <li><code>\"http2.receive_response_headers\"</code></li> <li><code>\"http2.receive_response_body\"</code></li> <li><code>\"http2.response_closed\"</code></li> </ul> <p>The exact set of trace events may be subject to change across different versions of <code>httpcore</code>. If you need to rely on a particular set of events it is recommended that you pin installation of the package to a fixed version.</p>"},{"location":"extensions/#sni_hostname","title":"<code>\"sni_hostname\"</code>","text":"<p>The server's hostname, which is used to confirm the hostname supplied by the SSL certificate.</p> <p>For example:</p> <pre><code>headers = {\"Host\": \"www.encode.io\"}\nextensions = {\"sni_hostname\": \"www.encode.io\"}\nresponse = httpcore.request(\n    \"GET\",\n    \"https://185.199.108.153\",\n    headers=headers,\n    extensions=extensions\n)\n</code></pre>"},{"location":"extensions/#target","title":"<code>\"target\"</code>","text":"<p>The target that is used as the HTTP target instead of the URL path.</p> <p>This enables support constructing requests that would otherwise be unsupported. In particular...</p> <ul> <li>Forward proxy requests using an absolute URI.</li> <li>Tunneling proxy requests using <code>CONNECT</code> with hostname as the target.</li> <li>Server-wide <code>OPTIONS *</code> requests.</li> </ul> <p>For example:</p> <pre><code>extensions = {\"target\": b\"www.encode.io:443\"}\nresponse = httpcore.request(\n    \"CONNECT\",\n    \"http://your-tunnel-proxy.com\",\n    headers=headers,\n    extensions=extensions\n)\n</code></pre>"},{"location":"extensions/#response-extensions","title":"Response Extensions","text":""},{"location":"extensions/#http_version","title":"<code>\"http_version\"</code>","text":"<p>The HTTP version, as bytes. Eg. <code>b\"HTTP/1.1\"</code>.</p> <p>When using HTTP/1.1 the response line includes an explicit version, and the value of this key could feasibly be one of <code>b\"HTTP/0.9\"</code>, <code>b\"HTTP/1.0\"</code>, or <code>b\"HTTP/1.1\"</code>.</p> <p>When using HTTP/2 there is no further response versioning included in the protocol, and the value of this key will always be <code>b\"HTTP/2\"</code>.</p>"},{"location":"extensions/#reason_phrase","title":"<code>\"reason_phrase\"</code>","text":"<p>The reason-phrase of the HTTP response, as bytes. For example <code>b\"OK\"</code>. Some servers may include a custom reason phrase, although this is not recommended.</p> <p>HTTP/2 onwards does not include a reason phrase on the wire.</p> <p>When no key is included, a default based on the status code may be used.</p>"},{"location":"extensions/#stream_id","title":"<code>\"stream_id\"</code>","text":"<p>When HTTP/2 is being used the <code>\"stream_id\"</code> response extension can be accessed to determine the ID of the data stream that the response was sent on.</p>"},{"location":"extensions/#network_stream","title":"<code>\"network_stream\"</code>","text":"<p>The <code>\"network_stream\"</code> extension allows developers to handle HTTP <code>CONNECT</code> and <code>Upgrade</code> requests, by providing an API that steps outside the standard request/response model, and can directly read or write to the network.</p> <p>The interface provided by the network stream:</p> <ul> <li><code>read(max_bytes, timeout = None) -&gt; bytes</code></li> <li><code>write(buffer, timeout = None)</code></li> <li><code>close()</code></li> <li><code>start_tls(ssl_context, server_hostname = None, timeout = None) -&gt; NetworkStream</code></li> <li><code>get_extra_info(info) -&gt; Any</code></li> </ul> <p>This API can be used as the foundation for working with HTTP proxies, WebSocket upgrades, and other advanced use-cases.</p> <p>See the network backends documentation for more information on working directly with network streams.</p>"},{"location":"extensions/#connect-requests","title":"<code>CONNECT</code> requests","text":"<p>A proxy CONNECT request using the network stream:</p> <pre><code># Formulate a CONNECT request...\n#\n# This will establish a connection to 127.0.0.1:8080, and then send the following...\n#\n# CONNECT http://www.example.com HTTP/1.1\nurl = \"http://127.0.0.1:8080\"\nextensions = {\"target: \"http://www.example.com\"}\nwith httpcore.stream(\"CONNECT\", url, extensions=extensions) as response:\n    network_stream = response.extensions[\"network_stream\"]\n\n    # Upgrade to an SSL stream...\n    network_stream = network_stream.start_tls(\n        ssl_context=httpcore.default_ssl_context(),\n        hostname=b\"www.example.com\",\n    )\n\n    # Manually send an HTTP request over the network stream, and read the response...\n    #\n    # For a more complete example see the httpcore `TunnelHTTPConnection` implementation.\n    network_stream.write(b\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\")\n    data = network_stream.read()\n    print(data)\n</code></pre>"},{"location":"extensions/#upgrade-requests","title":"<code>Upgrade</code> requests","text":"<p>Using the <code>wsproto</code> package to handle a websockets session:</p> <pre><code>import httpcore\nimport wsproto\nimport os\nimport base64\n\n\nurl = \"http://127.0.0.1:8000/\"\nheaders = {\n    b\"Connection\": b\"Upgrade\",\n    b\"Upgrade\": b\"WebSocket\",\n    b\"Sec-WebSocket-Key\": base64.b64encode(os.urandom(16)),\n    b\"Sec-WebSocket-Version\": b\"13\"\n}\nwith httpcore.stream(\"GET\", url, headers=headers) as response:\n    if response.status != 101:\n        raise Exception(\"Failed to upgrade to websockets\", response)\n\n    # Get the raw network stream.\n    network_steam = response.extensions[\"network_stream\"]\n\n    # Write a WebSocket text frame to the stream.\n    ws_connection = wsproto.Connection(wsproto.ConnectionType.CLIENT)\n    message = wsproto.events.TextMessage(\"hello, world!\")\n    outgoing_data = ws_connection.send(message)\n    network_steam.write(outgoing_data)\n\n    # Wait for a response.\n    incoming_data = network_steam.read(max_bytes=4096)\n    ws_connection.receive_data(incoming_data)\n    for event in ws_connection.events():\n        if isinstance(event, wsproto.events.TextMessage):\n            print(\"Got data:\", event.data)\n\n    # Write a WebSocket close to the stream.\n    message = wsproto.events.CloseConnection(code=1000)\n    outgoing_data = ws_connection.send(message)\n    network_steam.write(outgoing_data)\n</code></pre>"},{"location":"extensions/#extra-network-information","title":"Extra network information","text":"<p>The network stream abstraction also allows access to various low-level information that may be exposed by the underlying socket:</p> <pre><code>response = httpcore.request(\"GET\", \"https://www.example.com\")\nnetwork_stream = response.extensions[\"network_stream\"]\n\nclient_addr = network_stream.get_extra_info(\"client_addr\")\nserver_addr = network_stream.get_extra_info(\"server_addr\")\nprint(\"Client address\", client_addr)\nprint(\"Server address\", server_addr)\n</code></pre> <p>The socket SSL information is also available through this interface, although you need to ensure that the underlying connection is still open, in order to access it...</p> <pre><code>with httpcore.stream(\"GET\", \"https://www.example.com\") as response:\n    network_stream = response.extensions[\"network_stream\"]\n\n    ssl_object = network_stream.get_extra_info(\"ssl_object\")\n    print(\"TLS version\", ssl_object.version())\n</code></pre>"},{"location":"http2/","title":"HTTP/2","text":"<p>HTTP/2 is a major new iteration of the HTTP protocol, that provides a more efficient transport, with potential performance benefits. HTTP/2 does not change the core semantics of the request or response, but alters the way that data is sent to and from the server.</p> <p>Rather than the text format that HTTP/1.1 uses, HTTP/2 is a binary format. The binary format provides full request and response multiplexing, and efficient compression of HTTP headers. The stream multiplexing means that where HTTP/1.1 requires one TCP stream for each concurrent request, HTTP/2 allows a single TCP stream to handle multiple concurrent requests.</p> <p>HTTP/2 also provides support for functionality such as response prioritization, and server push.</p> <p>For a comprehensive guide to HTTP/2 you may want to check out \"HTTP2 Explained\".</p>"},{"location":"http2/#enabling-http2","title":"Enabling HTTP/2","text":"<p>When using the <code>httpcore</code> client, HTTP/2 support is not enabled by default, because HTTP/1.1 is a mature, battle-hardened transport layer, and our HTTP/1.1 implementation may be considered the more robust option at this point in time. It is possible that a future version of <code>httpcore</code> may enable HTTP/2 support by default.</p> <p>If you're issuing highly concurrent requests you might want to consider trying out our HTTP/2 support. You can do so by first making sure to install the optional HTTP/2 dependencies...</p> <pre><code>$ pip install 'httpcore[http2]'\n</code></pre> <p>And then instantiating a connection pool with HTTP/2 support enabled:</p> <pre><code>import httpcore\n\npool = httpcore.ConnectionPool(http2=True)\n</code></pre> <p>We can take a look at the difference in behaviour by issuing several outgoing requests in parallel.</p> <p>Start out by using a standard HTTP/1.1 connection pool:</p> <pre><code>import httpcore\nimport concurrent.futures\nimport time\n\n\ndef download(http, year):\n    http.request(\"GET\", f\"https://en.wikipedia.org/wiki/{year}\")\n\n\ndef main():\n    with httpcore.ConnectionPool() as http:\n        started = time.time()\n        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as threads:\n            for year in range(2000, 2020):\n                threads.submit(download, http, year)\n        complete = time.time()\n\n        for connection in http.connections:\n            print(connection)\n        print(\"Complete in %.3f seconds\" % (complete - started))\n\n\nmain()\n</code></pre> <p>If you run this with an HTTP/1.1 connection pool, you ought to see output similar to the following:</p> <pre><code>&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/1.1, IDLE, Request Count: 2]&gt;,\n&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/1.1, IDLE, Request Count: 3]&gt;,\n&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/1.1, IDLE, Request Count: 6]&gt;,\n&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/1.1, IDLE, Request Count: 5]&gt;,\n&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/1.1, IDLE, Request Count: 1]&gt;,\n&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/1.1, IDLE, Request Count: 1]&gt;,\n&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/1.1, IDLE, Request Count: 1]&gt;,\n&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/1.1, IDLE, Request Count: 1]&gt;\nComplete in 0.586 seconds\n</code></pre> <p>We can see that the connection pool required a number of connections in order to handle the parallel requests.</p> <p>If we now upgrade our connection pool to support HTTP/2:</p> <pre><code>with httpcore.ConnectionPool(http2=True) as http:\n    ...\n</code></pre> <p>And run the same script again, we should end up with something like this:</p> <pre><code>&lt;HTTPConnection ['https://en.wikipedia.org:443', HTTP/2, IDLE, Request Count: 20]&gt;\nComplete in 0.573 seconds\n</code></pre> <p>All of our requests have been handled over a single connection.</p> <p>Switching to HTTP/2 should not necessarily be considered an \"upgrade\". It is more complex, and requires more computational power, and so particularly in an interpreted language like Python it could be slower in some instances. Moreover, utilising multiple connections may end up connecting to multiple hosts, and could sometimes appear faster to the client, at the cost of requiring more server resources. Enabling HTTP/2 is most likely to be beneficial if you are sending requests in high concurrency, and may often be more well suited to an async context, rather than multi-threading.</p>"},{"location":"http2/#inspecting-the-http-version","title":"Inspecting the HTTP version","text":"<p>Enabling HTTP/2 support on the client does not necessarily mean that your requests and responses will be transported over HTTP/2, since both the client and the server need to support HTTP/2. If you connect to a server that only supports HTTP/1.1 the client will use a standard HTTP/1.1 connection instead.</p> <p>You can determine which version of the HTTP protocol was used by examining the <code>\"http_version\"</code> response extension.</p> <pre><code>import httpcore\n\npool = httpcore.ConnectionPool(http2=True)\nresponse = pool.request(\"GET\", \"https://www.example.com/\")\n\n# Should be one of b\"HTTP/2\", b\"HTTP/1.1\", b\"HTTP/1.0\", or b\"HTTP/0.9\".\nprint(response.extensions[\"http_version\"])\n</code></pre> <p>See the extensions documentation for more details.</p>"},{"location":"http2/#http2-negotiation","title":"HTTP/2 negotiation","text":"<p>Robust servers need to support both HTTP/2 and HTTP/1.1 capable clients, and so need some way to \"negotiate\" with the client which protocol version will be used.</p>"},{"location":"http2/#http2-over-https","title":"HTTP/2 over HTTPS","text":"<p>Generally the method used is for the server to advertise if it has HTTP/2 support during the part of the SSL connection handshake. This is known as ALPN - \"Application Layer Protocol Negotiation\".</p> <p>Most browsers only provide HTTP/2 support over HTTPS connections, and this is also the default behaviour that <code>httpcore</code> provides. If you enable HTTP/2 support you should still expect to see HTTP/1.1 connections for any <code>http://</code> URLs.</p>"},{"location":"http2/#http2-over-http","title":"HTTP/2 over HTTP","text":"<p>Servers can optionally also support HTTP/2 over HTTP by supporting the <code>Upgrade: h2c</code> header.</p> <p>This mechanism is not supported by <code>httpcore</code>. It requires an additional round-trip between the client and server, and also requires any request body to be sent twice.</p>"},{"location":"http2/#prior-knowledge","title":"Prior Knowledge","text":"<p>If you know in advance that the server you are communicating with will support HTTP/2, then you can enforce that the client uses HTTP/2, without requiring either ALPN support or an HTTP <code>Upgrade: h2c</code> header.</p> <p>This is managed by disabling HTTP/1.1 support on the connection pool:</p> <pre><code>pool = httpcore.ConnectionPool(http1=False, http2=True)\n</code></pre>"},{"location":"http2/#request-response-headers","title":"Request &amp; response headers","text":"<p>Because HTTP/2 frames the requests and responses somewhat differently to HTTP/1.1, there is a difference in some of the headers that are used.</p> <p>In order for the <code>httpcore</code> library to support both HTTP/1.1 and HTTP/2 transparently, the HTTP/1.1 style is always used throughout the API. Any differences in header styles are only mapped onto HTTP/2 at the internal network layer.</p>"},{"location":"http2/#request-headers","title":"Request headers","text":"<p>The following pseudo-headers are used by HTTP/2 in the request:</p> <ul> <li><code>:method</code> - The request method.</li> <li><code>:path</code> - Taken from the URL of the request.</li> <li><code>:authority</code> - Equivalent to the <code>Host</code> header in HTTP/1.1. In <code>httpcore</code> this is represented using the request <code>Host</code> header, which is automatically populated from the request URL if no <code>Host</code> header is explicitly included.</li> <li><code>:scheme</code> - Taken from the URL of the request.</li> </ul> <p>These pseudo-headers are included in <code>httpcore</code> as part of the <code>request.method</code> and <code>request.url</code> attributes, and through the <code>request.headers[\"Host\"]</code> header. They are not exposed directly by their psuedo-header names.</p> <p>The one other difference to be aware of is the <code>Transfer-Encoding: chunked</code> header.</p> <p>In HTTP/2 this header is never used, since streaming data is framed using a different mechanism.</p> <p>In <code>httpcore</code> the <code>Transfer-Encoding: chunked</code> header is always used to represent the presence of a streaming body on the request, and is automatically populated if required. However the header is only sent if the underlying connection ends up being HTTP/1.1, and is omitted if the underlying connection ends up being HTTP/2.</p>"},{"location":"http2/#response-headers","title":"Response headers","text":"<p>The following pseudo-header is used by HTTP/2 in the response:</p> <ul> <li><code>:status</code> - The response status code.</li> </ul> <p>In <code>httpcore</code> this is represented by the <code>response.status</code> attribute, rather than being exposed as a psuedo-header.</p>"},{"location":"logging/","title":"Logging","text":"<p>If you need to inspect the internal behaviour of <code>httpcore</code>, you can use Python's standard logging to output debug level information.</p> <p>For example, the following configuration...</p> <pre><code>import logging\nimport httpcore\n\nlogging.basicConfig(\n    format=\"%(levelname)s [%(asctime)s] %(name)s - %(message)s\",\n    datefmt=\"%Y-%m-%d %H:%M:%S\",\n    level=logging.DEBUG\n)\n\nhttpcore.request('GET', 'https://www.example.com')\n</code></pre> <p>Will send debug level output to the console, or wherever <code>stdout</code> is directed too...</p> <pre><code>DEBUG [2023-01-09 14:44:00] httpcore.connection - connect_tcp.started host='www.example.com' port=443 local_address=None timeout=None\nDEBUG [2023-01-09 14:44:00] httpcore.connection - connect_tcp.complete return_value=&lt;httpcore.backends.sync.SyncStream object at 0x109ba6610&gt;\nDEBUG [2023-01-09 14:44:00] httpcore.connection - start_tls.started ssl_context=&lt;ssl.SSLContext object at 0x109e427b0&gt; server_hostname='www.example.com' timeout=None\nDEBUG [2023-01-09 14:44:00] httpcore.connection - start_tls.complete return_value=&lt;httpcore.backends.sync.SyncStream object at 0x109e8b050&gt;\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - send_request_headers.started request=&lt;Request [b'GET']&gt;\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - send_request_headers.complete\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - send_request_body.started request=&lt;Request [b'GET']&gt;\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - send_request_body.complete\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - receive_response_headers.started request=&lt;Request [b'GET']&gt;\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Age', b'572646'), (b'Cache-Control', b'max-age=604800'), (b'Content-Type', b'text/html; charset=UTF-8'), (b'Date', b'Mon, 09 Jan 2023 14:44:00 GMT'), (b'Etag', b'\"3147526947+ident\"'), (b'Expires', b'Mon, 16 Jan 2023 14:44:00 GMT'), (b'Last-Modified', b'Thu, 17 Oct 2019 07:18:26 GMT'), (b'Server', b'ECS (nyb/1D18)'), (b'Vary', b'Accept-Encoding'), (b'X-Cache', b'HIT'), (b'Content-Length', b'1256')])\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - receive_response_body.started request=&lt;Request [b'GET']&gt;\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - receive_response_body.complete\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - response_closed.started\nDEBUG [2023-01-09 14:44:00] httpcore.http11 - response_closed.complete\nDEBUG [2023-01-09 14:44:00] httpcore.connection - close.started\nDEBUG [2023-01-09 14:44:00] httpcore.connection - close.complete\n</code></pre> <p>The exact formatting of the debug logging may be subject to change across different versions of <code>httpcore</code>. If you need to rely on a particular format it is recommended that you pin installation of the package to a fixed version.</p>"},{"location":"network-backends/","title":"Network Backends","text":"<p>The API layer at which <code>httpcore</code> interacts with the network is described as the network backend. Various backend implementations are provided, allowing <code>httpcore</code> to handle networking in different runtime contexts.</p>"},{"location":"network-backends/#working-with-network-backends","title":"Working with network backends","text":""},{"location":"network-backends/#the-default-network-backend","title":"The default network backend","text":"<p>Typically you won't need to specify a network backend, as a default will automatically be selected. However, understanding how the network backends fit in may be useful if you want to better understand the underlying architecture. Let's start by seeing how we can explicitly select the network backend.</p> <p>First we're making a standard HTTP request, using a connection pool:</p> <pre><code>import httpcore\n\nwith httpcore.ConnectionPool() as http:\n    response = http.request('GET', 'https://www.example.com')\n    print(response)\n</code></pre> <p>We can also have the same behavior, but be explicit with our selection of the network backend:</p> <pre><code>import httpcore\n\nnetwork_backend = httpcore.SyncBackend()\nwith httpcore.ConnectionPool(network_backend=network_backend) as http:\n    response = http.request('GET', 'https://www.example.com')\n    print(response)\n</code></pre> <p>The <code>httpcore.SyncBackend()</code> implementation handles the opening of TCP connections, and operations on the socket stream, such as reading, writing, and closing the connection.</p> <p>We can get a better understanding of this by using a network backend to send a basic HTTP/1.1 request directly:</p> <pre><code>import httpcore\n\n# Create an SSL context using 'certifi' for the certificates.\nssl_context = httpcore.default_ssl_context()\n\n# A basic HTTP/1.1 request as a plain bytestring.\nrequest = b'\\r\\n'.join([\n    b'GET / HTTP/1.1',\n    b'Host: www.example.com',\n    b'Accept: */*',\n    b'Connection: close',\n    b''\n])\n\n# Open a TCP stream and upgrade it to SSL.\nnetwork_backend = httpcore.SyncBackend()\nnetwork_stream = network_backend.connect_tcp(\"www.example.com\", 443)\nnetwork_stream = network_stream.start_tls(ssl_context, server_hostname=\"www.example.com\")\n\n# Send the HTTP request.\nnetwork_stream.write(request)\n\n# Read the HTTP response.\nwhile True:\n    response = network_stream.read(max_bytes=4096)\n    if response == b'':\n        break\n    print(response)\n\n# The output should look something like this:\n#\n# b'HTTP/1.1 200 OK\\r\\nAge: 600005\\r\\n [...] Content-Length: 1256\\r\\nConnection: close\\r\\n\\r\\n'\n# b'&lt;!doctype html&gt;\\n&lt;html&gt;\\n&lt;head&gt;\\n    &lt;title&gt;Example Domain&lt;/title&gt; [...] &lt;/html&gt;\\n'\n</code></pre>"},{"location":"network-backends/#async-network-backends","title":"Async network backends","text":"<p>If we're working with an <code>async</code> codebase, then we need to select a different backend.</p> <p>The <code>httpcore.AnyIOBackend</code> is suitable for usage if you're running under <code>asyncio</code>. This is a networking backend implemented using the <code>anyio</code> package.</p> <pre><code>import httpcore\nimport asyncio\n\nasync def main():\n    network_backend = httpcore.AnyIOBackend()\n    async with httpcore.AsyncConnectionPool(network_backend=network_backend) as http:\n        response = await http.request('GET', 'https://www.example.com')\n        print(response)\n\nasyncio.run(main())\n</code></pre> <p>The <code>AnyIOBackend</code> will work when running under either <code>asyncio</code> or <code>trio</code>. However, if you're working with async using the <code>trio</code> framework, then we recommend using the <code>httpcore.TrioBackend</code>.</p> <p>This will give you the same kind of networking behavior you'd have using <code>AnyIOBackend</code>, but there will be a little less indirection so it will be marginally more efficient and will present cleaner tracebacks in error cases.</p> <pre><code>import httpcore\nimport trio\n\nasync def main():\n    network_backend = httpcore.TrioBackend()\n    async with httpcore.AsyncConnectionPool(network_backend=network_backend) as http:\n        response = await http.request('GET', 'https://www.example.com')\n        print(response)\n\ntrio.run(main)\n</code></pre>"},{"location":"network-backends/#mock-network-backends","title":"Mock network backends","text":"<p>There are also mock network backends available that can be useful for testing purposes. These backends accept a list of bytes, and return network stream interfaces that return those byte streams.</p> <p>Here's an example of mocking a simple HTTP/1.1 response...</p> <pre><code>import httpcore\n\nnetwork_backend = httpcore.MockBackend([\n    b\"HTTP/1.1 200 OK\\r\\n\",\n    b\"Content-Type: plain/text\\r\\n\",\n    b\"Content-Length: 13\\r\\n\",\n    b\"\\r\\n\",\n    b\"Hello, world!\",\n])\nwith httpcore.ConnectionPool(network_backend=network_backend) as http:\n    response = http.request(\"GET\", \"https://example.com/\")\n    print(response.extensions['http_version'])\n    print(response.status)\n    print(response.content)\n</code></pre> <p>Mocking a HTTP/2 response is more complex, since it uses a binary format...</p> <pre><code>import hpack\nimport hyperframe.frame\nimport httpcore\n\ncontent = [\n    hyperframe.frame.SettingsFrame().serialize(),\n    hyperframe.frame.HeadersFrame(\n        stream_id=1,\n        data=hpack.Encoder().encode(\n            [\n                (b\":status\", b\"200\"),\n                (b\"content-type\", b\"plain/text\"),\n            ]\n        ),\n        flags=[\"END_HEADERS\"],\n    ).serialize(),\n    hyperframe.frame.DataFrame(\n        stream_id=1, data=b\"Hello, world!\", flags=[\"END_STREAM\"]\n    ).serialize(),\n]\n# Note that we instantiate the mock backend with an `http2=True` argument.\n# This ensures that the mock network stream acts as if the `h2` ALPN flag has been set,\n# and causes the connection pool to interact with the connection using HTTP/2.\nnetwork_backend = httpcore.MockBackend(content, http2=True)\nwith httpcore.ConnectionPool(network_backend=network_backend) as http:\n    response = http.request(\"GET\", \"https://example.com/\")\n    print(response.extensions['http_version'])\n    print(response.status)\n    print(response.content)\n</code></pre>"},{"location":"network-backends/#custom-network-backends","title":"Custom network backends","text":"<p>The base interface for network backends is provided as public API, allowing you to implement custom networking behavior.</p> <p>You can use this to provide advanced networking functionality such as:</p> <ul> <li>Network recording / replay.</li> <li>In-depth debug tooling.</li> <li>Handling non-standard SSL or DNS requirements.</li> </ul> <p>Here's an example that records the network response to a file on disk:</p> <pre><code>import httpcore\n\n\nclass RecordingNetworkStream(httpcore.NetworkStream):\n    def __init__(self, record_file, stream):\n        self.record_file = record_file\n        self.stream = stream\n\n    def read(self, max_bytes, timeout=None):\n        data = self.stream.read(max_bytes, timeout=timeout)\n        self.record_file.write(data)\n        return data\n\n    def write(self, buffer, timeout=None):\n        self.stream.write(buffer, timeout=timeout)\n\n    def close(self) -&gt; None:\n        self.stream.close()\n\n    def start_tls(\n        self,\n        ssl_context,\n        server_hostname=None,\n        timeout=None,\n    ):\n        self.stream = self.stream.start_tls(\n            ssl_context, server_hostname=server_hostname, timeout=timeout\n        )\n        return self\n\n    def get_extra_info(self, info):\n        return self.stream.get_extra_info(info)\n\n\nclass RecordingNetworkBackend(httpcore.NetworkBackend):\n    \"\"\"\n    A custom network backend that records network responses.\n    \"\"\"\n    def __init__(self, record_file):\n        self.record_file = record_file\n        self.backend = httpcore.SyncBackend()\n\n    def connect_tcp(\n        self,\n        host,\n        port,\n        timeout=None,\n        local_address=None,\n        socket_options=None,\n    ):\n        # Note that we're only using a single record file here,\n        # so even if multiple connections are opened the network\n        # traffic will all write to the same file.\n\n        # An alternative implementation might automatically use\n        # a new file for each opened connection.\n        stream = self.backend.connect_tcp(\n            host,\n            port,\n            timeout=timeout,\n            local_address=local_address,\n            socket_options=socket_options\n        )\n        return RecordingNetworkStream(self.record_file, stream)\n\n\n# Once you make the request, the raw HTTP/1.1 response will be available\n#\u00a0in the 'network-recording' file.\n#\n# Try switching to `http2=True` to see the difference when recording HTTP/2 binary network traffic,\n# or add `headers={'Accept-Encoding': 'gzip'}` to see HTTP content compression.\nwith open(\"network-recording\", \"wb\") as record_file:\n    network_backend = RecordingNetworkBackend(record_file)\n    with httpcore.ConnectionPool(network_backend=network_backend) as http:\n        response = http.request(\"GET\", \"https://www.example.com/\")\n        print(response)\n</code></pre>"},{"location":"network-backends/#reference","title":"Reference","text":""},{"location":"network-backends/#networking-backends","title":"Networking Backends","text":"<ul> <li><code>httpcore.SyncBackend</code></li> <li><code>httpcore.AnyIOBackend</code></li> <li><code>httpcore.TrioBackend</code></li> </ul>"},{"location":"network-backends/#mock-backends","title":"Mock Backends","text":"<ul> <li><code>httpcore.MockBackend</code></li> <li><code>httpcore.MockStream</code></li> <li><code>httpcore.AsyncMockBackend</code></li> <li><code>httpcore.AsyncMockStream</code></li> </ul>"},{"location":"network-backends/#base-interface","title":"Base Interface","text":"<ul> <li><code>httpcore.NetworkBackend</code></li> <li><code>httpcore.NetworkStream</code></li> <li><code>httpcore.AsyncNetworkBackend</code></li> <li><code>httpcore.AsyncNetworkStream</code></li> </ul>"},{"location":"proxies/","title":"Proxies","text":"<p>The <code>httpcore</code> package provides support for HTTP proxies, using either \"HTTP Forwarding\" or \"HTTP Tunnelling\". Forwarding is a proxy mechanism for sending requests to <code>http</code> URLs via an intermediate proxy. Tunnelling is a proxy mechanism for sending requests to <code>https</code> URLs via an intermediate proxy.</p> <p>Sending requests via a proxy is very similar to sending requests using a standard connection pool:</p> <pre><code>import httpcore\n\nproxy = httpcore.Proxy(\"http://127.0.0.1:8080/\")\npool = httpcore.ConnectionPool(proxy=proxy)\nr = proxy.request(\"GET\", \"https://www.example.com/\")\n\nprint(r)\n# &lt;Response [200]&gt;\n</code></pre> <p>You can test the <code>httpcore</code> proxy support, using the Python <code>proxy.py</code> tool:</p> <pre><code>$ pip install proxy.py\n$ proxy --hostname 127.0.0.1 --port 8080\n</code></pre> <p>Requests will automatically use either forwarding or tunnelling, depending on if the scheme is <code>http</code> or <code>https</code>.</p>"},{"location":"proxies/#authentication","title":"Authentication","text":"<p>Proxy authentication can be included in the initial configuration:</p> <pre><code>import httpcore\n\n# A `Proxy-Authorization` header will be included on the initial proxy connection.\nproxy = httpcore.Proxy(\n    url=\"http://127.0.0.1:8080/\",\n    auth=(\"&lt;username&gt;\", \"&lt;password&gt;\")\n)\npool = httpcore.ConnectionPool(proxy=proxy)\n</code></pre> <p>Custom headers can also be included:</p> <pre><code>import httpcore\nimport base64\n\n# Construct and include a `Proxy-Authorization` header.\nauth = base64.b64encode(b\"&lt;username&gt;:&lt;password&gt;\")\nproxy = httpcore.Proxy(\n    url=\"http://127.0.0.1:8080/\",\n    headers={\"Proxy-Authorization\": b\"Basic \" + auth}\n)\npool = httpcore.ConnectionPool(proxy=proxy)\n</code></pre>"},{"location":"proxies/#proxy-ssl","title":"Proxy SSL","text":"<p>The <code>httpcore</code> package also supports HTTPS proxies for http and https destinations.</p> <p>HTTPS proxies can be used in the same way that HTTP proxies are.</p> <pre><code>proxy = httpcore.Proxy(url=\"https://127.0.0.1:8080/\")\n</code></pre> <p>Also, when using HTTPS proxies, you may need to configure the SSL context, which you can do with the <code>ssl_context</code> argument.</p> <pre><code>import ssl\nimport httpcore\n\nproxy_ssl_context = ssl.create_default_context()\nproxy_ssl_context.check_hostname = False\n\nproxy = httpcore.Proxy(\n    url='https://127.0.0.1:8080/',\n    ssl_context=proxy_ssl_context\n)\npool = httpcore.ConnectionPool(proxy=proxy)\n</code></pre>"},{"location":"proxies/#http-versions","title":"HTTP Versions","text":"<p>If you use proxies, keep in mind that the <code>httpcore</code> package only supports proxies to HTTP/1.1 servers.</p>"},{"location":"proxies/#socks-proxy-support","title":"SOCKS proxy support","text":"<p>The <code>httpcore</code> package also supports proxies using the SOCKS5 protocol.</p> <p>Make sure to install the optional dependancy using <code>pip install 'httpcore[socks]'</code>.</p> <p>The <code>SOCKSProxy</code> class should be using instead of a standard connection pool:</p> <pre><code>import httpcore\n\n# Note that the SOCKS port is 1080.\nproxy = httpcore.Proxy(url=\"socks5://127.0.0.1:1080/\")\npool = httpcore.ConnectionPool(proxy=proxy)\nr = pool.request(\"GET\", \"https://www.example.com/\")\n</code></pre> <p>Authentication via SOCKS is also supported:</p> <pre><code>import httpcore\n\nproxy = httpcore.Proxy(\n    url=\"socks5://127.0.0.1:1080/\",\n    auth=(\"&lt;username&gt;\", \"&lt;password&gt;\"),\n)\npool = httpcore.ConnectionPool(proxy=proxy)\nr = pool.request(\"GET\", \"https://www.example.com/\")\n</code></pre>"},{"location":"proxies/#reference","title":"Reference","text":""},{"location":"proxies/#httpcoreproxy","title":"<code>httpcore.Proxy</code>","text":""},{"location":"quickstart/","title":"Quickstart","text":"<p>For convenience, the <code>httpcore</code> package provides a couple of top-level functions that you can use for sending HTTP requests. You probably don't want to integrate against functions if you're writing a library that uses <code>httpcore</code>, but you might find them useful for testing <code>httpcore</code> from the command-line, or if you're writing a simple script that doesn't require any of the connection pooling or advanced configuration that <code>httpcore</code> offers.</p>"},{"location":"quickstart/#sending-a-request","title":"Sending a request","text":"<p>We'll start off by sending a request...</p> <pre><code>import httpcore\n\nresponse = httpcore.request(\"GET\", \"https://www.example.com/\")\n\nprint(response)\n# &lt;Response [200]&gt;\nprint(response.status)\n# 200\nprint(response.headers)\n# [(b'Accept-Ranges', b'bytes'), (b'Age', b'557328'), (b'Cache-Control', b'max-age=604800'), ...]\nprint(response.content)\n# b'&lt;!doctype html&gt;\\n&lt;html&gt;\\n&lt;head&gt;\\n&lt;title&gt;Example Domain&lt;/title&gt;\\n\\n&lt;meta charset=\"utf-8\"/&gt;\\n ...'\n</code></pre>"},{"location":"quickstart/#request-headers","title":"Request headers","text":"<p>Request headers may be included either in a dictionary style, or as a list of two-tuples.</p> <pre><code>import httpcore\nimport json\n\nheaders = {'User-Agent': 'httpcore'}\nr = httpcore.request('GET', 'https://httpbin.org/headers', headers=headers)\n\nprint(json.loads(r.content))\n# {\n#     'headers': {\n#         'Host': 'httpbin.org',\n#         'User-Agent': 'httpcore',\n#         'X-Amzn-Trace-Id': 'Root=1-616ff5de-5ea1b7e12766f1cf3b8e3a33'\n#     }\n# }\n</code></pre> <p>The keys and values may either be provided as strings or as bytes. Where strings are provided they may only contain characters within the ASCII range <code>chr(0)</code> - <code>chr(127)</code>. To include characters outside this range you must deal with any character encoding explicitly, and pass bytes as the header keys/values.</p> <p>The <code>Host</code> header will always be automatically included in any outgoing request, as it is strictly required to be present by the HTTP protocol.</p> <p>Note that the <code>X-Amzn-Trace-Id</code> header shown in the example above is not an outgoing request header, but has been added by a gateway server.</p>"},{"location":"quickstart/#request-body","title":"Request body","text":"<p>A request body can be included either as bytes...</p> <pre><code>import httpcore\nimport json\n\nr = httpcore.request('POST', 'https://httpbin.org/post', content=b'Hello, world')\n\nprint(json.loads(r.content))\n# {\n#     'args': {},\n#     'data': 'Hello, world',\n#     'files': {},\n#     'form': {},\n#     'headers': {\n#         'Host': 'httpbin.org',\n#         'Content-Length': '12',\n#         'X-Amzn-Trace-Id': 'Root=1-61700258-00e338a124ca55854bf8435f'\n#     },\n#     'json': None,\n#     'origin': '68.41.35.196',\n#     'url': 'https://httpbin.org/post'\n# }\n</code></pre> <p>Or as an iterable that returns bytes...</p> <pre><code>import httpcore\nimport json\n\nwith open(\"hello-world.txt\", \"rb\") as input_file:\n    r = httpcore.request('POST', 'https://httpbin.org/post', content=input_file)\n\nprint(json.loads(r.content))\n# {\n#     'args': {},\n#     'data': 'Hello, world',\n#     'files': {},\n#     'form': {},\n#     'headers': {\n#         'Host': 'httpbin.org',\n#         'Transfer-Encoding': 'chunked',\n#         'X-Amzn-Trace-Id': 'Root=1-61700258-00e338a124ca55854bf8435f'\n#     },\n#     'json': None,\n#     'origin': '68.41.35.196',\n#     'url': 'https://httpbin.org/post'\n# }\n</code></pre> <p>When a request body is included, either a <code>Content-Length</code> header or a <code>Transfer-Encoding: chunked</code> header will be automatically included.</p> <p>The <code>Content-Length</code> header is used when passing bytes, and indicates an HTTP request with a body of a pre-determined length.</p> <p>The <code>Transfer-Encoding: chunked</code> header is the mechanism that HTTP/1.1 uses for sending HTTP request bodies without a pre-determined length.</p>"},{"location":"quickstart/#streaming-responses","title":"Streaming responses","text":"<p>When using the <code>httpcore.request()</code> function, the response body will automatically be read to completion, and made available in the <code>response.content</code> attribute.</p> <p>Sometimes you may be dealing with large responses and not want to read the entire response into memory. The <code>httpcore.stream()</code> function provides a mechanism for sending a request and dealing with a streaming response:</p> <pre><code>import httpcore\n\nwith httpcore.stream('GET', 'https://example.com') as response:\n    for chunk in response.iter_stream():\n        print(f\"Downloaded: {chunk}\")\n</code></pre> <p>Here's a more complete example that demonstrates downloading a response:</p> <pre><code>import httpcore\n\nwith httpcore.stream('GET', 'https://speed.hetzner.de/100MB.bin') as response:\n    with open(\"download.bin\", \"wb\") as output_file:\n        for chunk in response.iter_stream():\n            output_file.write(chunk)\n</code></pre> <p>The <code>httpcore.stream()</code> API also allows you to conditionally read the response...</p> <pre><code>import httpcore\n\nwith httpcore.stream('GET', 'https://example.com') as response:\n    content_length = [int(v) for k, v in response.headers if k.lower() == b'content-length'][0]\n    if content_length &gt; 100_000_000:\n        raise Exception(\"Response too large.\")\n    response.read()  # `response.content` is now available.\n</code></pre>"},{"location":"quickstart/#reference","title":"Reference","text":""},{"location":"quickstart/#httpcorerequest","title":"<code>httpcore.request()</code>","text":"<p>Sends an HTTP request, returning the response.</p> <pre><code>response = httpcore.request(\"GET\", \"https://www.example.com/\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>bytes | str</code> <p>The HTTP method for the request. Typically one of <code>\"GET\"</code>, <code>\"OPTIONS\"</code>, <code>\"HEAD\"</code>, <code>\"POST\"</code>, <code>\"PUT\"</code>, <code>\"PATCH\"</code>, or <code>\"DELETE\"</code>.</p> required <code>url</code> <code>URL | bytes | str</code> <p>The URL of the HTTP request. Either as an instance of <code>httpcore.URL</code>, or as str/bytes.</p> required <code>headers</code> <code>HeaderTypes</code> <p>The HTTP request headers. Either as a dictionary of str/bytes, or as a list of two-tuples of str/bytes.</p> <code>None</code> <code>content</code> <code>bytes | Iterator[bytes] | None</code> <p>The content of the request body. Either as bytes, or as a bytes iterator.</p> <code>None</code> <code>extensions</code> <code>Extensions | None</code> <p>A dictionary of optional extra information included on the request. Possible keys include <code>\"timeout\"</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>An instance of <code>httpcore.Response</code>.</p> Source code in <code>httpcore/__init__.py</code> <pre><code>def request(\n    method: bytes | str,\n    url: URL | bytes | str,\n    *,\n    headers: HeaderTypes = None,\n    content: bytes | typing.Iterator[bytes] | None = None,\n    extensions: Extensions | None = None,\n) -&gt; Response:\n    \"\"\"\n    Sends an HTTP request, returning the response.\n\n    ```\n    response = httpcore.request(\"GET\", \"https://www.example.com/\")\n    ```\n\n    Arguments:\n        method: The HTTP method for the request. Typically one of `\"GET\"`,\n            `\"OPTIONS\"`, `\"HEAD\"`, `\"POST\"`, `\"PUT\"`, `\"PATCH\"`, or `\"DELETE\"`.\n        url: The URL of the HTTP request. Either as an instance of `httpcore.URL`,\n            or as str/bytes.\n        headers: The HTTP request headers. Either as a dictionary of str/bytes,\n            or as a list of two-tuples of str/bytes.\n        content: The content of the request body. Either as bytes,\n            or as a bytes iterator.\n        extensions: A dictionary of optional extra information included on the request.\n            Possible keys include `\"timeout\"`.\n\n    Returns:\n        An instance of `httpcore.Response`.\n    \"\"\"\n    with ConnectionPool() as pool:\n        return pool.request(\n            method=method,\n            url=url,\n            headers=headers,\n            content=content,\n            extensions=extensions,\n        )\n</code></pre>"},{"location":"quickstart/#httpcorestream","title":"<code>httpcore.stream()</code>","text":"<p>Sends an HTTP request, returning the response within a content manager.</p> <pre><code>with httpcore.stream(\"GET\", \"https://www.example.com/\") as response:\n    ...\n</code></pre> <p>When using the <code>stream()</code> function, the body of the response will not be automatically read. If you want to access the response body you should either use <code>content = response.read()</code>, or <code>for chunk in response.iter_content()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>bytes | str</code> <p>The HTTP method for the request. Typically one of <code>\"GET\"</code>, <code>\"OPTIONS\"</code>, <code>\"HEAD\"</code>, <code>\"POST\"</code>, <code>\"PUT\"</code>, <code>\"PATCH\"</code>, or <code>\"DELETE\"</code>.</p> required <code>url</code> <code>URL | bytes | str</code> <p>The URL of the HTTP request. Either as an instance of <code>httpcore.URL</code>, or as str/bytes.</p> required <code>headers</code> <code>HeaderTypes</code> <p>The HTTP request headers. Either as a dictionary of str/bytes, or as a list of two-tuples of str/bytes.</p> <code>None</code> <code>content</code> <code>bytes | Iterator[bytes] | None</code> <p>The content of the request body. Either as bytes, or as a bytes iterator.</p> <code>None</code> <code>extensions</code> <code>Extensions | None</code> <p>A dictionary of optional extra information included on the request. Possible keys include <code>\"timeout\"</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Response]</code> <p>An instance of <code>httpcore.Response</code>.</p> Source code in <code>httpcore/_api.py</code> <pre><code>@contextlib.contextmanager\ndef stream(\n    method: bytes | str,\n    url: URL | bytes | str,\n    *,\n    headers: HeaderTypes = None,\n    content: bytes | typing.Iterator[bytes] | None = None,\n    extensions: Extensions | None = None,\n) -&gt; typing.Iterator[Response]:\n    \"\"\"\n    Sends an HTTP request, returning the response within a content manager.\n\n    ```\n    with httpcore.stream(\"GET\", \"https://www.example.com/\") as response:\n        ...\n    ```\n\n    When using the `stream()` function, the body of the response will not be\n    automatically read. If you want to access the response body you should\n    either use `content = response.read()`, or `for chunk in response.iter_content()`.\n\n    Arguments:\n        method: The HTTP method for the request. Typically one of `\"GET\"`,\n            `\"OPTIONS\"`, `\"HEAD\"`, `\"POST\"`, `\"PUT\"`, `\"PATCH\"`, or `\"DELETE\"`.\n        url: The URL of the HTTP request. Either as an instance of `httpcore.URL`,\n            or as str/bytes.\n        headers: The HTTP request headers. Either as a dictionary of str/bytes,\n            or as a list of two-tuples of str/bytes.\n        content: The content of the request body. Either as bytes,\n            or as a bytes iterator.\n        extensions: A dictionary of optional extra information included on the request.\n            Possible keys include `\"timeout\"`.\n\n    Returns:\n        An instance of `httpcore.Response`.\n    \"\"\"\n    with ConnectionPool() as pool:\n        with pool.stream(\n            method=method,\n            url=url,\n            headers=headers,\n            content=content,\n            extensions=extensions,\n        ) as response:\n            yield response\n</code></pre>"},{"location":"requests-responses-urls/","title":"Requests, Responses, and URLs","text":"<p>TODO</p>"},{"location":"requests-responses-urls/#requests","title":"Requests","text":"<p>Request instances in <code>httpcore</code> are deliberately simple, and only include the essential information required to represent an HTTP request.</p> <p>Properties on the request are plain byte-wise representations.</p> <pre><code>&gt;&gt;&gt; request = httpcore.Request(\"GET\", \"https://www.example.com/\")\n&gt;&gt;&gt; request.method\nb\"GET\"\n&gt;&gt;&gt; request.url\nhttpcore.URL(scheme=b\"https\", host=b\"www.example.com\", port=None, target=b\"/\")\n&gt;&gt;&gt; request.headers\n[(b'Host', b'www.example.com')]\n&gt;&gt;&gt; request.stream\n&lt;httpcore.ByteStream [0 bytes]&gt;\n</code></pre> <p>The interface is liberal in the types that it accepts, but specific in the properties that it uses to represent them. For example, headers may be specified as a dictionary of strings, but internally are represented as a list of <code>(byte, byte)</code> tuples.</p> <p>```python</p> <p>headers = {\"User-Agent\": \"custom\"} request = httpcore.Request(\"GET\", \"https://www.example.com/\", headers=headers) request.headers [(b'Host', b'www.example.com'), (b\"User-Agent\", b\"custom\")]</p>"},{"location":"requests-responses-urls/#responses","title":"Responses","text":"<p>...</p>"},{"location":"requests-responses-urls/#urls","title":"URLs","text":"<p>...</p>"},{"location":"requests-responses-urls/#reference","title":"Reference","text":""},{"location":"requests-responses-urls/#httpcorerequest","title":"<code>httpcore.Request</code>","text":"<p>An HTTP request.</p>"},{"location":"requests-responses-urls/#httpcore.Request.__init__","title":"<code>__init__(self, method, url, *, headers=None, content=None, extensions=None)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>method</code> <code>bytes | str</code> <p>The HTTP request method, either as a string or bytes. For example: <code>GET</code>.</p> required <code>url</code> <code>URL | bytes | str</code> <p>The request URL, either as a <code>URL</code> instance, or as a string or bytes. For example: <code>\"https://www.example.com\".</code></p> required <code>headers</code> <code>HeaderTypes</code> <p>The HTTP request headers.</p> <code>None</code> <code>content</code> <code>bytes | Iterable[bytes] | AsyncIterable[bytes] | None</code> <p>The content of the request body.</p> <code>None</code> <code>extensions</code> <code>Extensions | None</code> <p>A dictionary of optional extra information included on the request. Possible keys include <code>\"timeout\"</code>, and <code>\"trace\"</code>.</p> <code>None</code> Source code in <code>httpcore/__init__.py</code> <pre><code>def __init__(\n    self,\n    method: bytes | str,\n    url: URL | bytes | str,\n    *,\n    headers: HeaderTypes = None,\n    content: bytes\n    | typing.Iterable[bytes]\n    | typing.AsyncIterable[bytes]\n    | None = None,\n    extensions: Extensions | None = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        method: The HTTP request method, either as a string or bytes.\n            For example: `GET`.\n        url: The request URL, either as a `URL` instance, or as a string or bytes.\n            For example: `\"https://www.example.com\".`\n        headers: The HTTP request headers.\n        content: The content of the request body.\n        extensions: A dictionary of optional extra information included on\n            the request. Possible keys include `\"timeout\"`, and `\"trace\"`.\n    \"\"\"\n    self.method: bytes = enforce_bytes(method, name=\"method\")\n    self.url: URL = enforce_url(url, name=\"url\")\n    self.headers: list[tuple[bytes, bytes]] = enforce_headers(\n        headers, name=\"headers\"\n    )\n    self.stream: typing.Iterable[bytes] | typing.AsyncIterable[bytes] = (\n        enforce_stream(content, name=\"content\")\n    )\n    self.extensions = {} if extensions is None else extensions\n\n    if \"target\" in self.extensions:\n        self.url = URL(\n            scheme=self.url.scheme,\n            host=self.url.host,\n            port=self.url.port,\n            target=self.extensions[\"target\"],\n        )\n</code></pre>"},{"location":"requests-responses-urls/#httpcoreresponse","title":"<code>httpcore.Response</code>","text":"<p>An HTTP response.</p>"},{"location":"requests-responses-urls/#httpcore.Response.__init__","title":"<code>__init__(self, status, *, headers=None, content=None, extensions=None)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>status</code> <code>int</code> <p>The HTTP status code of the response. For example <code>200</code>.</p> required <code>headers</code> <code>HeaderTypes</code> <p>The HTTP response headers.</p> <code>None</code> <code>content</code> <code>bytes | Iterable[bytes] | AsyncIterable[bytes] | None</code> <p>The content of the response body.</p> <code>None</code> <code>extensions</code> <code>Extensions | None</code> <p>A dictionary of optional extra information included on the responseself.Possible keys include <code>\"http_version\"</code>, <code>\"reason_phrase\"</code>, and <code>\"network_stream\"</code>.</p> <code>None</code> Source code in <code>httpcore/__init__.py</code> <pre><code>def __init__(\n    self,\n    status: int,\n    *,\n    headers: HeaderTypes = None,\n    content: bytes\n    | typing.Iterable[bytes]\n    | typing.AsyncIterable[bytes]\n    | None = None,\n    extensions: Extensions | None = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        status: The HTTP status code of the response. For example `200`.\n        headers: The HTTP response headers.\n        content: The content of the response body.\n        extensions: A dictionary of optional extra information included on\n            the responseself.Possible keys include `\"http_version\"`,\n            `\"reason_phrase\"`, and `\"network_stream\"`.\n    \"\"\"\n    self.status: int = status\n    self.headers: list[tuple[bytes, bytes]] = enforce_headers(\n        headers, name=\"headers\"\n    )\n    self.stream: typing.Iterable[bytes] | typing.AsyncIterable[bytes] = (\n        enforce_stream(content, name=\"content\")\n    )\n    self.extensions = {} if extensions is None else extensions\n\n    self._stream_consumed = False\n</code></pre>"},{"location":"requests-responses-urls/#httpcoreurl","title":"<code>httpcore.URL</code>","text":"<p>Represents the URL against which an HTTP request may be made.</p> <p>The URL may either be specified as a plain string, for convienence:</p> <pre><code>url = httpcore.URL(\"https://www.example.com/\")\n</code></pre> <p>Or be constructed with explicitily pre-parsed components:</p> <pre><code>url = httpcore.URL(scheme=b'https', host=b'www.example.com', port=None, target=b'/')\n</code></pre> <p>Using this second more explicit style allows integrations that are using <code>httpcore</code> to pass through URLs that have already been parsed in order to use libraries such as <code>rfc-3986</code> rather than relying on the stdlib. It also ensures that URL parsing is treated identically at both the networking level and at any higher layers of abstraction.</p> <p>The four components are important here, as they allow the URL to be precisely specified in a pre-parsed format. They also allow certain types of request to be created that could not otherwise be expressed.</p> <p>For example, an HTTP request to <code>http://www.example.com/</code> forwarded via a proxy at <code>http://localhost:8080</code>...</p> <pre><code># Constructs an HTTP request with a complete URL as the target:\n# GET https://www.example.com/ HTTP/1.1\nurl = httpcore.URL(\n    scheme=b'http',\n    host=b'localhost',\n    port=8080,\n    target=b'https://www.example.com/'\n)\nrequest = httpcore.Request(\n    method=\"GET\",\n    url=url\n)\n</code></pre> <p>Another example is constructing an <code>OPTIONS *</code> request...</p> <pre><code># Constructs an 'OPTIONS *' HTTP request:\n# OPTIONS * HTTP/1.1\nurl = httpcore.URL(scheme=b'https', host=b'www.example.com', target=b'*')\nrequest = httpcore.Request(method=\"OPTIONS\", url=url)\n</code></pre> <p>This kind of request is not possible to formulate with a URL string, because the <code>/</code> delimiter is always used to demark the target from the host/port portion of the URL.</p> <p>For convenience, string-like arguments may be specified either as strings or as bytes. However, once a request is being issue over-the-wire, the URL components are always ultimately required to be a bytewise representation.</p> <p>In order to avoid any ambiguity over character encodings, when strings are used as arguments, they must be strictly limited to the ASCII range <code>chr(0)</code>-<code>chr(127)</code>. If you require a bytewise representation that is outside this range you must handle the character encoding directly, and pass a bytes instance.</p>"},{"location":"requests-responses-urls/#httpcore.URL.__init__","title":"<code>__init__(self, url='', *, scheme=b'', host=b'', port=None, target=b'')</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>url</code> <code>bytes | str</code> <p>The complete URL as a string or bytes.</p> <code>''</code> <code>scheme</code> <code>bytes | str</code> <p>The URL scheme as a string or bytes. Typically either <code>\"http\"</code> or <code>\"https\"</code>.</p> <code>b''</code> <code>host</code> <code>bytes | str</code> <p>The URL host as a string or bytes. Such as <code>\"www.example.com\"</code>.</p> <code>b''</code> <code>port</code> <code>int | None</code> <p>The port to connect to. Either an integer or <code>None</code>.</p> <code>None</code> <code>target</code> <code>bytes | str</code> <p>The target of the HTTP request. Such as <code>\"/items?search=red\"</code>.</p> <code>b''</code> Source code in <code>httpcore/__init__.py</code> <pre><code>def __init__(\n    self,\n    url: bytes | str = \"\",\n    *,\n    scheme: bytes | str = b\"\",\n    host: bytes | str = b\"\",\n    port: int | None = None,\n    target: bytes | str = b\"\",\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        url: The complete URL as a string or bytes.\n        scheme: The URL scheme as a string or bytes.\n            Typically either `\"http\"` or `\"https\"`.\n        host: The URL host as a string or bytes. Such as `\"www.example.com\"`.\n        port: The port to connect to. Either an integer or `None`.\n        target: The target of the HTTP request. Such as `\"/items?search=red\"`.\n    \"\"\"\n    if url:\n        parsed = urllib.parse.urlparse(enforce_bytes(url, name=\"url\"))\n        self.scheme = parsed.scheme\n        self.host = parsed.hostname or b\"\"\n        self.port = parsed.port\n        self.target = (parsed.path or b\"/\") + (\n            b\"?\" + parsed.query if parsed.query else b\"\"\n        )\n    else:\n        self.scheme = enforce_bytes(scheme, name=\"scheme\")\n        self.host = enforce_bytes(host, name=\"host\")\n        self.port = port\n        self.target = enforce_bytes(target, name=\"target\")\n</code></pre>"},{"location":"table-of-contents/","title":"API Reference","text":"<ul> <li>Quickstart<ul> <li><code>httpcore.request()</code></li> <li><code>httpcore.stream()</code></li> </ul> </li> <li>Requests, Responses, and URLs<ul> <li><code>httpcore.Request</code></li> <li><code>httpcore.Response</code></li> <li><code>httpcore.URL</code></li> </ul> </li> <li>Connection Pools<ul> <li><code>httpcore.ConnectionPool</code></li> </ul> </li> <li>Proxies<ul> <li><code>httpcore.Proxy</code></li> </ul> </li> <li>Connections<ul> <li><code>httpcore.HTTPConnection</code></li> <li><code>httpcore.HTTP11Connection</code></li> <li><code>httpcore.HTTP2Connection</code></li> </ul> </li> <li>Async Support<ul> <li><code>httpcore.AsyncConnectionPool</code></li> <li><code>httpcore.AsyncHTTPConnection</code></li> <li><code>httpcore.AsyncHTTP11Connection</code></li> <li><code>httpcore.AsyncHTTP2Connection</code></li> </ul> </li> <li>Network Backends<ul> <li>Sync<ul> <li><code>httpcore.backends.sync.SyncBackend</code></li> <li><code>httpcore.backends.mock.MockBackend</code></li> </ul> </li> <li>Async<ul> <li><code>httpcore.backends.auto.AutoBackend</code></li> <li><code>httpcore.backends.asyncio.AsyncioBackend</code></li> <li><code>httpcore.backends.trio.TrioBackend</code></li> <li><code>httpcore.backends.mock.AsyncMockBackend</code></li> </ul> </li> <li>Base interfaces<ul> <li><code>httpcore.backends.base.NetworkBackend</code></li> <li><code>httpcore.backends.base.AsyncNetworkBackend</code></li> </ul> </li> </ul> </li> <li>Exceptions<ul> <li><code>httpcore.TimeoutException</code><ul> <li><code>httpcore.PoolTimeout</code></li> <li><code>httpcore.ConnectTimeout</code></li> <li><code>httpcore.ReadTimeout</code></li> <li><code>httpcore.WriteTimeout</code></li> </ul> </li> <li><code>httpcore.NetworkError</code><ul> <li><code>httpcore.ConnectError</code></li> <li><code>httpcore.ReadError</code></li> <li><code>httpcore.WriteError</code></li> </ul> </li> <li><code>httpcore.ProtocolError</code><ul> <li><code>httpcore.RemoteProtocolError</code></li> <li><code>httpcore.LocalProtocolError</code></li> </ul> </li> <li><code>httpcore.ProxyError</code></li> <li><code>httpcore.UnsupportedProtocol</code></li> </ul> </li> </ul>"}]}